#pragma once
/*
절차적 프로그래밍
정렬 알고리즘 및 자료구조를 실습해 봤는데 불편한 점이 있다.
거의 비슷한 기능을 매번 다시 구현해야 했다. 단일 연결 리스트와 이중 연결리스트는 구조체
멤버 하나만 다를 뿐인데, 모든 함수들을 다시 작성해야 했다.
이런식으로 프로그램으 ㅣ기능을 함수 단위를 바탄으로 작성하는 것을 절차적 프로그래밍이라 부른다.
함수를 다른 말로 프로시저라고도 부르기 때문에 절차적이라 함은 함수들로 프로그램을 작성한다는 의미가 되낟.

객체 지향 프로그래밍
이것이 C++의 핵심이다. ㅇ객체 지향 프로그래밍에 대해 언급하기 전에 객체가 무엇인지 알아보자
Object 객체
	현실 생활을 둘러싼 대상을 하나의 객체라고 볼 수 있다. 사람 한 명 한 명 자동차 한 대 하 ㄴ대
	건물 하 나 한하 각각 객체들이다. 이런 객체들이 모여서 현실 생활을 만들어 낸느 것이다.
	마찬가지로 우리가 만드는 프로그램도 객체들로 구성된 하나으 ㅣ큰 집합이다. 현실 세계를
	모델링 하듯이 프로그래밍을 하는 방법이 바로 객체 지향 프로그래밍이다.
	객체는 다음과 같이 상태와 행동을 가지고 있다. 옆 동네에서 객를 한마리 대여롸 보자.
Class
	클래ㅡ라는 것은 객체를 표현하기 위한 설계도 또는 틀이라고 보면 된다. 즉, 옆집 개를 나타내기 위해서는 일반적인
	개를 묘사해야 한다. 위 상태와 행동을 모두 가지고 있어야 한다.
	이런 추상적인 정보를 이용해서 옆집 개를 묘사할 수 있는데 이런 추상적인 정보를 클래스라 부른다.
	많이 보던 구조체와 매우 유사하지만 변수 말고 함수도 포함된 개념이다.
인스턴스
	추상적인 클래스에서 구체적인 객체를 생성하는 것이 인스턴스화이다. 이렇게 만들어진 객체를 인스턴스라 부
	른다.
	인스턴스의 사전적 의미는 예, 사례라는 뜻이다. 추상적인 개에서 하나으 ㅣ구체적인 사례를 만든 것이기 때문
	에 이런 단어를 사용하낟. 그럼 클래스로부터 객체를 인스턴화 해보자.
	구조체 변수를 정의하는 것과 큰 차이가 없다.
	Dog라는 추상적ㅇ니 개념에서 똘이라는 이름을 가진 구체적인 사례를 만들어 냈다. 동일하게
	이런 방식의 Dog라는 클래스로 부터 옆짐 뒷집 개도 무두 객체로 만들 수 있다.
	객체의 상태나 행동에 접근하려면 .을 찍어서 접근하면 된다. 위에서는 똘이의 상태 세부 정보를
	설정 하고, 짓기와 구르기 행동을 수행하도록 한 것이다.
C++의 클래스 워낙 OOP 언어들이 많아서 간단히 정리하면 된다.
상태와 행동은 OOP의 일반화된 개념이고, 각 언어별로 이러한 개념을 서로 다른 표현으로 사용하고 있다.
OOP의 특징
	흔히 OOP는 5가지의 특징을 가지고 있어야 한다고 한다.
		객체
		클래스
		캡슐화
		상속
		다형성
	캡슐화
		캡슐이라는 것은 무엇인가를 안에 집어 넣고 케이스를 씌운 것을 말한다. 가챠라던가 알약이라던가 등등
		캡슐이다. 이런 캡슐화의 기본적인 목적은 안에 무엇이 들어 있는지 모르게 하는 것입니다. 가챠 내용물을 안다면 가치가
		떨어질 테고,
		알약의 내용물을 안다면 환자가 먹지 않을 수도 있다. 게다가 내용물을 모르지만 항상 정량이고 
		내용물을 신경쓰지 않아도 된다.
		가끔 캡슐화는 정보 은닉의 개념으로 사용되기도 한다.
		불필요한 정보는 노출시키지 않고, 괜히 건드려서는 좋을 것이 없는 ㅓㄳ은 숨겨둔다.
	상속
		상속 또는 파생이라 부른다.
		위에서 서술한 옆집 개를 조금 더 넓은 의미로 살펴보면 다음과 같다.
		위 그림과 같이 각 객체들은 상관관계를 가지고 있으며 옆집 개 똘리는 개라는 상위 개념ㅇ을 가지고
		있다. 조금 더 상위로 동물이라는 개념도 가지고 있다. 이러한 계층 구조를 
		상속이라 부른다.
		여러 가지 용어가 있는 대 역시 한번 정리하자.
		나이와 색상은 모든 동물이 가지고 있는 상태이다. 개는 그런 동물의 상태를 그대로 이어받고, 개만의
		고유한 품종 상태를 가지고 있다. 행동 역시 마찬가지
		개를 인스턴스화한 똘이는 동물의 상태행동을 모두 가지고 있으며 개의 상태행동 역시 가지고 있다.
	다형성
		똘이는 개이면서 동물이다. 즉, 하나으 ㅣ객체가 어떤 경우에는 동물로 취급되고 어떤 경우에는
		개로 취급될 수 있다.
		상황에 따라 서로 다른 형태로 사용되는 것을 다형성이라 한다.
		이러한 다형성은 포인터를 통해서 얻을 수 있는데, 객체가 존재하는 메모리를 가리키는 포인터를 다음과 같이
		다양하게 해석할 수 있갇.
		옆집 개 똘이는 동물이다. 따라서 똘이를 동묽로 취급할 수 있다. 당연히 동물의 행동을 수행할 ㅅ ㅜ있고
		동물이 개라는 것을 명확하게 해 준 다음에는 개의 행동도 수행할 수 있다.
기타 용어
	생성자/ 소멸자
	객체가 생서욀때 불리는 것이 생성자이고 사라질 때 불리는 것이 소멸자 이다.
	C++에서 객체를 만들 때는 항상 생성자가 가장 먼저 작동한다.
	마찬가지로 소멸될 때 소멸자가 불린다.
	정적 맴버
	상태행동은 각 개체 고유한 값으로 만들어진다. 클래스로 똘이를 객체화 하면 상태행동은
	똘이라는 객체에 종속되어 진다.
	이런 특성과 반대되는 것이 정적 멤버로 static이라는 키워드가 붙는다.
	이렇게 정적ㅇ니 상태 행동은 클래스를 인스턴스화 해서 객체로 만들지 않아도 클래스에서 바로 사용할 수 있다.
	추상클래스
	추상클래스는 추상적인 개념을 담고있기 때문에 추상클래스 스스로 인스턴스화 할 수 없다.
	이를 인스턴스화 하려면 추상 클랫ㅡ를 상송 받아 자식 클래스에서 인스턴스화 해야 한다.
	아래에 설명할 인터페이스와 비슷하지만 여러 자식 클래스에서 공유할 수 있는 부모 클래스의 공통적인 정의를 제공하는 것이 추상 클래스으 ㅣ목적이다.
	추상 클래스는 추상 상태와 추상 행동을 가질 수 있는데 이 추상 메서드는 구현이 없이
	정의만 들어있다. 추상 클래스를 상송한 자식 클래슨느 무조건 이 추상 매서드를 구현해 줘야 한다.
	인터페이스
	서로 다른 두 장치를 접속시켜주는 부분이라는 뜻의 인터페이스는 USB와 같은 것을 의미한다.
	가령 A사 키보드를 USB로 컴퓨터에 꼽으나 B사 키보드를 꼽으나 타이핑은 정상적으로 잘된다.
	표준 입력 방식을 정해 놓고 이를 각 키보드사가 규격을 지키도록 가각의 방식으로 설계한다.
	이런 규격을 인터페이스라고 하며 C++에서는 추상 클래스를 사용하여 설계한다.
	보통 인터페이스는 상태는 없고 행동만 있으며, 실제 행동을 구현하지는 않는다.
	즉 빈 껍데기만 있으면 실제 구현은 이 인터페이스를 상속받은 클래스에서 구현해 준다.
*/

/*
POD
	직역하면 간단하고 오래된 데이터라는 의미로 단순한 메모리 구조를 가지는 객체를 말한다.
	Old에서 추측할 수 있겠지만 C언어에서 제공되는 타입들이 POD이다.
	POD의 장점은 원본 메모리에서 다른 메모리로 복사나 이동이 매우 쉬워서 컴퓨터 성능에 큰 부담이 없다는
	점이다.

	클래스를 작성하며 느끼겠지만 내부 구조가 복잡해지고 직접 메모리를 관리해야 하는 경우들이 생기는데 이런
	친구들은 POD에 속하지 않는다.

	C++에서는 POD다음과 같은 의미론으로 정의해 두었다.
		표준 레이아웃 타입
		C언어와 같은 레이아웃을 가지고 있다고 본다.
		간단한 타입
		사용자가 정의한 매우 간단한 자료 구조를 말한다.
	POD가 되기 위해서는 = default 키워드로 암시적 기본 생성자를 명시해야 한다.
무명 객체
	변수 초기화가 클래스 생성자와 비슷하게 생김
	다시 정리하자면 지금까지 사용한 일반 타입들 역시 내부에서는 객체로 처리된다.
	지금까지 살펴본 변수의 특성은 사실 C++객체의 특성이라고 볼 수 있다.
	return x * x;
	이번에는 반환값에 대해 조금 더 살펴보겠다.
	일반 타입 역시 객체라고 생각해 보면, 위 코드는 x * x를 담아 둘 수 있는 임시 객체가 필요하다.
	계산 결과를 저장한 다음 반환해야 하니까.
	즉 다음과 같다.
	int temp = x * x;
	return temp;
	컴파일러 내부에서는 이 작업이 이뤄진다만 임시로 사용하는 객체로 해당 코드 이외에는 사용할 필요가
	없으므로, 굳이 변수명을 붙이지 않고 사용한다. 이를 이름없는 객체라 부른다.
	즉 위 코드에는 다음과 같은 작업이 숨어 있다.
	quare(x)에서 x가 리터럴 2로 치환
	인자 2가 Square(int x)의 매개변수 x에 복사
	x * x를 무명객체에 저장
	무명 객체 반환 & 소멸

	반환값을 살펴봤다고 해서 무명객체가 반환할 때만 생성되는 것은 아니다. 대부분의 연산식에 이런 무명객체가
	사용된다.
	클래스를 사용하면ㄴ 객체가 생성될 때를 추적할 수 있으니, 무명객체를 직접 살펴본다.
	일반 타입 int와 비슷하게, 간단한 정수 멤버오 ㅏ초기화 및 + 연산자를 가지고 있다.
	int로 살펴본 예제들을 클래스로 변환해서 살펴보면 실제로 생성한 C1, C2이외에ㅗ 생성자가 3번 불리는 걸
	볼 수 있다. 이들이 무명 객체이다.
	+연산자를 오버로딩한 코드는 위와 같이 새로운 객체를 만들어서 반환해야 하조. 여기서 만들어지는
	겁니다.
	다음으로 테스트에 사용한 Square() 함수를 살펴본다. 이 친구는 CallByValue이므로 조금 더 효율적으로 만들기 위해 참조형
	을 사용해 보자.
*/

/*
C++ 프로그래밍은 클래스로 시작해서 클래스로 끝난다.
	클래스의 정의
		Class <클래스 이름>
			[접근제한자1] :
				<멤버>
					[접근제한자2] :
						멤버
						...
	클래스는 멤버들의 집합으로 이뤄진 데이터 형식이다.
	클래스의 크기는 구조체와 마찬가지로 멤버에 따라 변한다. 하지만 클래스의 크기에 멤버 함수는
	영향을 주지 않는다. 구조체와 동일한 방식으로 8바이트만 사용되며 멤버 함수는 시그니쳐 정보로 개별 처리되어 
	Cat::Meaw() 형태로 다른 함수들과 함께 특정 공간에 일괄 저장된다.
접근제한자
	클래스는 내부에서 사용되는 데이터는 다음의 3가지 방법으로 숨길 수 있다.
	public
	protected
	private
	클래스 내부/외부에서 모두 사용이 가능하다. 멤버함수는 물론이고, 객체로 만든 후 객체를 통해서도 읽고/쓸수있다.
	자신과 자신을 기반으로 하는 파생클래스에서 사용ㅇ ㅣ가능하다. 자신의 멤버함수 및 파생된
	멤버함수에서 읽고쓸수있다.
	클래스 내부에서만 사용이 가능하다. 기본 값으로 생략하면 private이다.
	즉, 멤버 함수에서만 해당 변수를 일고 쓸수 있다.
	접근 제한자는 동일한 속성을 묶을 수도 있고, 여러 번 사용해도 되기 때문에 보기좋은 코드를 작성할 때 사용하면된다.
이름 규칙
	클래스의 이름 규칙은 다음과 같은 룰을 사용한다.
	클래스 이름 첫글자 대문자 및 나머지 소문자
	멤버 변수 소문자.
	멤버 함수 파스칼 표기법
	이런 표기법은 소속팀마다 전부 다르기 때문에 유연하게 대응하는 것이 좋다.
클래스와 구조체
	멤버 함수를 제외하면 거의 구조체와 비슷하다. 사실 구조체는 모든 멤버가 public인 클래스의 일부분이라고 봐도 된다.
	즉 이미 여러분은 클래스를 알게 모르게 사용하고 있던 것
	게다가 C++에서는 구조체에 멤버함수를 작성해도 전혀 문제 없다.
	구조체 : 멤버 변수들만 존재하는 자료구조
	클래스 : 멤버 함수가 필요한 자료구조

멤버 함수의 구현
	멤버 함수는 당연히 본제가 있어야 한다. 클래스 선언 내부에 간단히 다음과 같이 만들 수 있다.
	위와 같이 간단한 함수는 이렇게 작성해도 보기 불편함이 없다.
	멤버 함수도 정의를 분리할 수 있다.
	반환형 클래스이름::함수명(매개변수 목록)
		반환
	일반 함수와 거의 비슷하지만 이 함수가 클래스에 속해 있다는 것을 알리기 위해
	몇가지 차이가 존재한다.
	위와 같이 두 개의 클래스가 있을 경우를 생각해 보자. 두 멤버함수는 동일한 이름이기 때문에
	구분해 주지 않으면 함수를 구현하기 어렵다.
	멤버 함수의 특징을 정리해 보면 다음과 같다.
		범위해결 연산자
			클래스이름::함수명 형태로 멤버함수의 소속 클래스를 명시한다. 이러현 ::를 범위 해결 연산자
			라 한다.
		접근제한자 생략
			함수의 선언에 이미 존재하므로 정의에는 생략한다.
	멤버 함수를 하나 더 만들어 보자. mAge 멤버는 private이라서 외부에서 접근할 방법이 없다.
	하지만 외수에서 mAge를 사용할 경우에는 어떻게 할까?

	private멤버변수는 클래스 내부에서만 접근이 가능하다고 했으므로 멤버 변수는 멤버 함수에서 제한 없이 사용이
	가능하다. 위와 같이 public으로 된 멤버 함수를 사용해서 그 값을 돌려주면 mAge변수에 신경쓰지 않고
	값을 구할 수 있다는 장점이 있다.

	멤버 함수의 선ㅇ너 순서
	이 코드는 f1() 단계에서 f2()가 선언되어 있지 않으므로 에러가 발생한다.
	하지만 멤버함수들은 이런 제약이 없다.
	클래스의 선언은 모든 내용이 마무리되는;을 만나는 순간 이뤄지는 것이므로 멤버함수들은
	그 존재를 서로 알고 있다.

this
	여기서 문제 mAge는 누구 것일까?
	비교를 위해 구조체와 일반 함수로 간단히 만들어 보자.
	위와 같이 Dog라는 타입의 객체에서 mAge를 반환해야 한다. 따라서 매개 변수로 객체를 반드시 넘겨주어야만
	해당 객체의 멤버를 접근할 수 있다.

	클래스 멤버함수의 경우를 살펴보자.
	mAge는 어떤 객체를 참고해야 할까? 이건 이 함수를 호출하느 쪽을 비교해 보면 알 수 있다.
	구조체 멤버함수
	멤버함수는 사용할 때 명시적으로 객체를 적어 주어야 한다.
	그렇기 때문에 멤버 함수는 항상 어떤 오브젝트에서 호출된 것인지 알고 있으므로 함수에 암시적 객체가
	존재한다고 가정할 수 있다.
	따라서 위 문제에 대한 정답은 Dog 클래스로 인스턴스화한 오브젝트의 멤버라는 점이다.
	클래스는 단순히 청사진 용도로 타입을 만드는 것 일 뿌니며, 실제 값은 메모리에 이름을 붙여서 할당한
	인스턴스가 들고 있다는 점을 주의해야 한다.

	이런 암시적 오브젝트를 명시적으로 사용하기 위해서는 this라는 키워드를 사용할 수 있다.
	this는 멤버 함수를 호출한 객체의 포인터를 나타낸다.
	
	this는 포인터라는 사실을 명심해야 한다.
	this는 객체 자신을 반환하거나 할 때 유용하게 사용되는데, 다음에 연산자와 관련된 기능를 살펴볼 때 
	추가로 설명한다. 모든 멤버 함수에서는 this라느 포인터가 존재한다.

멤버 함수 구현 분리
*/