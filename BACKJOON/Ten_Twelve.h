#pragma once
/*
절차적 프로그래밍
정렬 알고리즘 및 자료구조를 실습해 봤는데 불편한 점이 있다.
거의 비슷한 기능을 매번 다시 구현해야 했다. 단일 연결 리스트와 이중 연결리스트는 구조체
멤버 하나만 다를 뿐인데, 모든 함수들을 다시 작성해야 했다.
이런식으로 프로그램으 ㅣ기능을 함수 단위를 바탄으로 작성하는 것을 절차적 프로그래밍이라 부른다.
함수를 다른 말로 프로시저라고도 부르기 때문에 절차적이라 함은 함수들로 프로그램을 작성한다는 의미가 되낟.

객체 지향 프로그래밍
이것이 C++의 핵심이다. ㅇ객체 지향 프로그래밍에 대해 언급하기 전에 객체가 무엇인지 알아보자
Object 객체
	현실 생활을 둘러싼 대상을 하나의 객체라고 볼 수 있다. 사람 한 명 한 명 자동차 한 대 하 ㄴ대
	건물 하 나 한하 각각 객체들이다. 이런 객체들이 모여서 현실 생활을 만들어 낸느 것이다.
	마찬가지로 우리가 만드는 프로그램도 객체들로 구성된 하나으 ㅣ큰 집합이다. 현실 세계를
	모델링 하듯이 프로그래밍을 하는 방법이 바로 객체 지향 프로그래밍이다.
	객체는 다음과 같이 상태와 행동을 가지고 있다. 옆 동네에서 객를 한마리 대여롸 보자.
Class
	클래ㅡ라는 것은 객체를 표현하기 위한 설계도 또는 틀이라고 보면 된다. 즉, 옆집 개를 나타내기 위해서는 일반적인
	개를 묘사해야 한다. 위 상태와 행동을 모두 가지고 있어야 한다.
	이런 추상적인 정보를 이용해서 옆집 개를 묘사할 수 있는데 이런 추상적인 정보를 클래스라 부른다.
	많이 보던 구조체와 매우 유사하지만 변수 말고 함수도 포함된 개념이다.
인스턴스
	추상적인 클래스에서 구체적인 객체를 생성하는 것이 인스턴스화이다. 이렇게 만들어진 객체를 인스턴스라 부
	른다.
	인스턴스의 사전적 의미는 예, 사례라는 뜻이다. 추상적인 개에서 하나으 ㅣ구체적인 사례를 만든 것이기 때문
	에 이런 단어를 사용하낟. 그럼 클래스로부터 객체를 인스턴화 해보자.
	구조체 변수를 정의하는 것과 큰 차이가 없다.
	Dog라는 추상적ㅇ니 개념에서 똘이라는 이름을 가진 구체적인 사례를 만들어 냈다. 동일하게
	이런 방식의 Dog라는 클래스로 부터 옆짐 뒷집 개도 무두 객체로 만들 수 있다.
	객체의 상태나 행동에 접근하려면 .을 찍어서 접근하면 된다. 위에서는 똘이의 상태 세부 정보를
	설정 하고, 짓기와 구르기 행동을 수행하도록 한 것이다.
C++의 클래스 워낙 OOP 언어들이 많아서 간단히 정리하면 된다.
상태와 행동은 OOP의 일반화된 개념이고, 각 언어별로 이러한 개념을 서로 다른 표현으로 사용하고 있다.
OOP의 특징
	흔히 OOP는 5가지의 특징을 가지고 있어야 한다고 한다.
		객체
		클래스
		캡슐화
		상속
		다형성
	캡슐화
		캡슐이라는 것은 무엇인가를 안에 집어 넣고 케이스를 씌운 것을 말한다. 가챠라던가 알약이라던가 등등
		캡슐이다. 이런 캡슐화의 기본적인 목적은 안에 무엇이 들어 있는지 모르게 하는 것입니다. 가챠 내용물을 안다면 가치가
		떨어질 테고,
		알약의 내용물을 안다면 환자가 먹지 않을 수도 있다. 게다가 내용물을 모르지만 항상 정량이고 
		내용물을 신경쓰지 않아도 된다.
		가끔 캡슐화는 정보 은닉의 개념으로 사용되기도 한다.
		불필요한 정보는 노출시키지 않고, 괜히 건드려서는 좋을 것이 없는 ㅓㄳ은 숨겨둔다.
	상속
		상속 또는 파생이라 부른다.
		위에서 서술한 옆집 개를 조금 더 넓은 의미로 살펴보면 다음과 같다.
		위 그림과 같이 각 객체들은 상관관계를 가지고 있으며 옆집 개 똘리는 개라는 상위 개념ㅇ을 가지고
		있다. 조금 더 상위로 동물이라는 개념도 가지고 있다. 이러한 계층 구조를 
		상속이라 부른다.
		여러 가지 용어가 있는 대 역시 한번 정리하자.
		나이와 색상은 모든 동물이 가지고 있는 상태이다. 개는 그런 동물의 상태를 그대로 이어받고, 개만의
		고유한 품종 상태를 가지고 있다. 행동 역시 마찬가지
		개를 인스턴스화한 똘이는 동물의 상태행동을 모두 가지고 있으며 개의 상태행동 역시 가지고 있다.
	다형성
		똘이는 개이면서 동물이다. 즉, 하나으 ㅣ객체가 어떤 경우에는 동물로 취급되고 어떤 경우에는
		개로 취급될 수 있다.
		상황에 따라 서로 다른 형태로 사용되는 것을 다형성이라 한다.
		이러한 다형성은 포인터를 통해서 얻을 수 있는데, 객체가 존재하는 메모리를 가리키는 포인터를 다음과 같이
		다양하게 해석할 수 있갇.
		옆집 개 똘이는 동물이다. 따라서 똘이를 동묽로 취급할 수 있다. 당연히 동물의 행동을 수행할 ㅅ ㅜ있고
		동물이 개라는 것을 명확하게 해 준 다음에는 개의 행동도 수행할 수 있다.
기타 용어
	생성자/ 소멸자
	객체가 생서욀때 불리는 것이 생성자이고 사라질 때 불리는 것이 소멸자 이다.
	C++에서 객체를 만들 때는 항상 생성자가 가장 먼저 작동한다.
	마찬가지로 소멸될 때 소멸자가 불린다.
	정적 맴버
	상태행동은 각 개체 고유한 값으로 만들어진다. 클래스로 똘이를 객체화 하면 상태행동은
	똘이라는 객체에 종속되어 진다.
	이런 특성과 반대되는 것이 정적 멤버로 static이라는 키워드가 붙는다.
	이렇게 정적ㅇ니 상태 행동은 클래스를 인스턴스화 해서 객체로 만들지 않아도 클래스에서 바로 사용할 수 있다.
	추상클래스
	추상클래스는 추상적인 개념을 담고있기 때문에 추상클래스 스스로 인스턴스화 할 수 없다.
	이를 인스턴스화 하려면 추상 클랫ㅡ를 상송 받아 자식 클래스에서 인스턴스화 해야 한다.
	아래에 설명할 인터페이스와 비슷하지만 여러 자식 클래스에서 공유할 수 있는 부모 클래스의 공통적인 정의를 제공하는 것이 추상 클래스으 ㅣ목적이다.
	추상 클래스는 추상 상태와 추상 행동을 가질 수 있는데 이 추상 메서드는 구현이 없이
	정의만 들어있다. 추상 클래스를 상송한 자식 클래슨느 무조건 이 추상 매서드를 구현해 줘야 한다.
	인터페이스
	서로 다른 두 장치를 접속시켜주는 부분이라는 뜻의 인터페이스는 USB와 같은 것을 의미한다.
	가령 A사 키보드를 USB로 컴퓨터에 꼽으나 B사 키보드를 꼽으나 타이핑은 정상적으로 잘된다.
	표준 입력 방식을 정해 놓고 이를 각 키보드사가 규격을 지키도록 가각의 방식으로 설계한다.
	이런 규격을 인터페이스라고 하며 C++에서는 추상 클래스를 사용하여 설계한다.
	보통 인터페이스는 상태는 없고 행동만 있으며, 실제 행동을 구현하지는 않는다.
	즉 빈 껍데기만 있으면 실제 구현은 이 인터페이스를 상속받은 클래스에서 구현해 준다.
*/

/*
POD
	직역하면 간단하고 오래된 데이터라는 의미로 단순한 메모리 구조를 가지는 객체를 말한다.
	Old에서 추측할 수 있겠지만 C언어에서 제공되는 타입들이 POD이다.
	POD의 장점은 원본 메모리에서 다른 메모리로 복사나 이동이 매우 쉬워서 컴퓨터 성능에 큰 부담이 없다는
	점이다.

	클래스를 작성하며 느끼겠지만 내부 구조가 복잡해지고 직접 메모리를 관리해야 하는 경우들이 생기는데 이런
	친구들은 POD에 속하지 않는다.

	C++에서는 POD다음과 같은 의미론으로 정의해 두었다.
		표준 레이아웃 타입
		C언어와 같은 레이아웃을 가지고 있다고 본다.
		간단한 타입
		사용자가 정의한 매우 간단한 자료 구조를 말한다.
	POD가 되기 위해서는 = default 키워드로 암시적 기본 생성자를 명시해야 한다.
무명 객체
	변수 초기화가 클래스 생성자와 비슷하게 생김
	다시 정리하자면 지금까지 사용한 일반 타입들 역시 내부에서는 객체로 처리된다.
	지금까지 살펴본 변수의 특성은 사실 C++객체의 특성이라고 볼 수 있다.
	return x * x;
	이번에는 반환값에 대해 조금 더 살펴보겠다.
	일반 타입 역시 객체라고 생각해 보면, 위 코드는 x * x를 담아 둘 수 있는 임시 객체가 필요하다.
	계산 결과를 저장한 다음 반환해야 하니까.
	즉 다음과 같다.
	int temp = x * x;
	return temp;
	컴파일러 내부에서는 이 작업이 이뤄진다만 임시로 사용하는 객체로 해당 코드 이외에는 사용할 필요가
	없으므로, 굳이 변수명을 붙이지 않고 사용한다. 이를 이름없는 객체라 부른다.
	즉 위 코드에는 다음과 같은 작업이 숨어 있다.
	quare(x)에서 x가 리터럴 2로 치환
	인자 2가 Square(int x)의 매개변수 x에 복사
	x * x를 무명객체에 저장
	무명 객체 반환 & 소멸

	반환값을 살펴봤다고 해서 무명객체가 반환할 때만 생성되는 것은 아니다. 대부분의 연산식에 이런 무명객체가
	사용된다.
	클래스를 사용하면ㄴ 객체가 생성될 때를 추적할 수 있으니, 무명객체를 직접 살펴본다.
	일반 타입 int와 비슷하게, 간단한 정수 멤버오 ㅏ초기화 및 + 연산자를 가지고 있다.
	int로 살펴본 예제들을 클래스로 변환해서 살펴보면 실제로 생성한 C1, C2이외에ㅗ 생성자가 3번 불리는 걸
	볼 수 있다. 이들이 무명 객체이다.
	+연산자를 오버로딩한 코드는 위와 같이 새로운 객체를 만들어서 반환해야 하조. 여기서 만들어지는
	겁니다.
	다음으로 테스트에 사용한 Square() 함수를 살펴본다. 이 친구는 CallByValue이므로 조금 더 효율적으로 만들기 위해 참조형
	을 사용해 보자.
*/