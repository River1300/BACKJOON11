#pragma once
/*
클래스 고급
형변환과 다형성
RPG게임 캐릭터를 만들어 보자
새로운 프로젝트를 만들고 다음과 같이 Character클래스와 Warrior클래스를 만들어 보자.
각 생성자와 초기화는 확인을 위해 각각 메시지를 출력하고 Attack역시 구분을 위해 메시지를 구분해 주면 된다.

다형성을 이용하여 Warrior인스턴스를 Character* 에 배정하여 가상 함수 Attack을 호출하였다.
그 이외에도 기반 클래스 생성자, 가상 소멸자, cosnt멤버 함수 등의 기능이 사용되었다.

전사가 레벨업을 해서 두 번 베기를 해운다. 그럼 Warrior::DoubleSlach()함수가 필요하다.
pHero->DoubleSlash()가 호출되지 않는다.
pHero는 Character*이고 가상 함수 테이블에는 Attack만 들어 있어서 찾을 수 없다.
두번 베기를 Character에 올려야 할까
안된다. 전사 전용 스킬을 Character가 가지고 있는것은 비효율 적이다. 해당 함수는
Charater에서 파생되는 수 많은 클래스 중 오직 Warrior만 사용하는 것인데 이를 일반화 시키는 것은
좋지 않는다.
이런 문제를 해결하려면 강제로 Character*에서 Warrior*로 변환해야 한다. 힙에 생성된 객체는 Warrior이므로 가능
하다.
((Warrior*)pHero)->DoubleSlach();
pHero를 명시적 형변환을 사용한 다음 위와 같이 호출이 가능하다.
지금 작성한 코드는 명확하게 pHero가 Warrior라는 것을 알지만, 복잡한 코드 속에서는 아무리
프로그래머라도 장담하기 어렵다. 가령 pHero가 다른 클래스인 경우에는 해당 프로그램은
크래시가 발생하고 말 것이다.
C++에서는 이런 위험한 상황을 막기 위해 형변환 연산자를 준비해 뒀다. 연산자에 대해 알아보기 전에
상속에서 형변환에 대해 용어를 정리하자.
상향 변환
파생 클래스 -> 기반 클래스
안전한 변환이라 암시적 변환도 충분
Character* pHero = new Warrior;

하향변환
기반 클래스 -> 파생 클래스
런타임에 체크하지 않으면 결과를 알 수 없다.
(Warrior*) pHero

staticCast
컴파일 시간에 형변환을 결정하는 연산자로 다음과 같이 사용된다.
static_cast<new type> expressios
기본적인 암시적 형변환과 구조적으로 같지만 조금더 엄격하다.
프로그래머가 어떤 타입을 어떤 타입으로 변환하는 지 명확하게 알고 있다면 정적 변환을 하용하면 된다.

형변환을 한 뒤 꼭 반환값이 정상인지 확인하기 바람
잘못된 포인터에 접근하는 것은 항상 치명적인 문제가 됨

dynamic_cast
실행시간에 동적으로 타입을 변환하는 연산자로 다음과 같이 사용된다.
dynamic_cast < new type> expression
클래스의 포인터 및 찹조형에서만 가능하며 주어진 포인터를 대상 타입의 완전히 유효한 객체에 대한 포인터로 변환흔
것을 보장한다. 실행 시간에 동적으로 판단하기 위해서는 rtti이라는 정보들이 필요한데 특정 컴파일러는 꺼져있
을 수도 있다.

비주얼 스튜디오에서는 기본으로 사용하게 되어 있으므로 큰 문제는 없을 것이지만
혹시 다른 컴파일러를 사용하면 확인해야 한다.
가장 안전함을 보장하지만, 형변환을 위해 rtti라는 추가 정보를 사용하기 때문에 성능에
영향을 줄 수 있다.

reinterpret_cast
새로 해석하다라는 단어 뜻을 지닌 만큼 어떠한 형변환도 수행하려고 하는 위험하지만 유용한 녀석이다. 객체의
자료를 바이너리 데이터로 해석한 다음 해당 타입을 ㅗ변환을 시도한다.
float f = 10.0f
std::cout<<*reinterpret_cast<int*>(&f);
명시적으로 intf를 하면 오버플로가 되지 않아 10이 되겠지만 위 변환은 완전히 다르다.
부동 소수점 표현을 위한 메모리 공간을 2진수로 변환한 다음 정수로 변환하기 때문에 예상치 못한 값이 나온다.

심지어 아무런 상관 없는 클래스도 강제로 변환한다.

주로 데이터 파일을 변환하거나 할 때 사용하는 표기법이다.

const cast
상수를 변환해 준다.
const 기호 추가도 가능하고 제거도 가능하다. 단, 포인터 및 참 조형만 가능하다.
위 예제는 컴파일러 에러, 인자로 cosnt cha*를 넘겨 주기 때문 char*로 변환이 혀용되지 않는다.
이런 경우 cosnt_cast로 const를 제거하는 변환을 할 수 있다.
Pirnt(const_cast<char*>(myString));


추상 클래스
RPG캐릭터로 돌아가 이번에는 몬스터를 추가해 보자.
플레이어가 조작하는 전사와 새로 추가할 악마와 늑대 몬스터
각각 기능을 정리해 놓고 보면 다음과 같이 묶을 수 있다.

전사든 악마든 늑대든 모두 필수적으로 공격 사망 을 처리해야만 한다.
앞으로 추가되는 직업이나 몬스터 역시 모두 반드시 필요한 것이다.
위와 같이 어떤 객체를 표현할 때, 기반 클래스에서 공통된 기능을 잘 정리해 두는 것이 좋다.

그런데 사실 Character의 공격 사망은 의미가 없다. Character는 단순한 공통 개념일 뿐이다.
따라서 함수에서는 아무것도 안해도 된다.

생성자/소멸자 확인을 위한 코드는 지금은 의미가 없어서 모두 삭제하고 빈 함수로 다시 만든다.
Character.cpp의 내용ㅇ느 모두 지운다.
이 클래스는 스스로는 어떠한 연산을 수행하지 않지만 Character에서 파생되는 클래스들에게 일종의
약속을 만들어 준다.
Character상속 받으려면 Attack(), Dead()를 꼭 구현

이미 만들어둔 Warrior는 Attack()과 DoubleSlach만 구현했고 Dead는 없다.
당연히 컴파일은 성공핟낟 기반 클래스의 가상 함수를 상속하지 않아도 인스턴스를 만들 수 있다.

순수 가상 함수
하지만 조금 더 엄하게 규격을 정하고 싶을것, 캐릭터의 공격 사망 루틴이 없으면 의미가 없으므로 반드시 만들
어야 상속을 받을 수 있다고, 이런 것을 pure virtual function이라 한다.

위와 같이 가상 함수 선언 뒤에 =0을 붙여 주면 이 함수는 순수 가상 함수라는 의미가 된다.
순수 가상 함수는 해당 함수를 상속받아서 정의하지 안으면 인스턴스를 만들 수 없게 해준다.
위와 같이 수정한 다음 빌드를 해보면 추상 클래스를 인스턴스화 할 수 없다.

이렇게 순수 가상함수들로만 이루어진 클래스는 약속이외의 어떠한 역할도 하지 않는다.
이러한 클래스를 추상 기반 클래스라 부른다.
추상 클래스 자체로는 인스턴스도 만들 수 있다.

이렇게 순수 가상 함수들로만 이루어진 클래스는 약속이외의 어떠한 역할도 하지 안흐나다.
이러한 클래스를 추상 기반 클래스라 부른다.
추상 클래스 자체로는 인스턴스도 만들 수 없다.

추상 클래스 : 순수 가상 함수를 하나라도 가지고 있는 클래스
	인스턴스 불가
	기반 클래스로만 사용할 것
	파생 클래스는 모든 순수 가상 함수를 오버라이딩
*/

/*
멤버 함수의 포인터
멤버 함수의 포인터에 대해 설명하기 전에, 우선 기존 함수 포인터를 정리해 보자.
int(*f)(int x)
위 표현은 반환값 int를 가지고 int를 매개변수로 하는 함수 포인터의 의미가 된다. int* f(int x)는 완전히
다른 의미이므로 괄호에 주의
이런 표현은 한눈에 보기도 힘들뿐 반복해서 타이핑 하기 불편하다. 편리하게 만드는 것부터 시작하면
타입을 재정의 하는 것은 typedef와 using을 통해 살펴 봤었는데 이를 사용하면 함수 포인터 역시
간단히 재정의 가능하다.
typedef typedef int (*FunctionPtr) (int);
using using FunctionPtr = int(*)(int);
훨씬 보기 좋고 편리한 것은 using,
int Sigma(FunctionPtr f, int m , int n){}

정적 멤버 함수의 포인터
당연히 에러가 발생, 함수를 구현할 때는 다음과 같이 클래스에 속한 것들은 클래스에 속한 것이라고 알려 줬다.
범위 해결 지정자:: 를 사용해서 클래스에 속해 있다고 알려줬다.
int MyFunctions::NormalFunction(int x){}
에러가 발생 한다.
문법적으로 표준이 아니라는 의미로 올바른 표현을 써 달라는 것, 일반 함수는 암시적으로 자동적으로 함수 포인터
로 변환되ㅣㅈ만 멤버 함수는 그렇지 않기 때문에 멤버 함수의 주소를 넘겨 줘야 한다.
멤버 함수를 변환할 수 없다는 군, 클래스의 의미를 다시 생각해 보면, 실제 클래스는 인스턴스화 되지 않으면 아무런
의미가 없다.인스턴스화 하지 않고 객체에 접근하는 방법은 정적 멤버 밖에 없다.

멤버 함수 포인터를 사용할 때 정적 멤버 함수를 사용하는 것, 이런 식으로 비록 클래스이지만 연산들만으로 구성하는 경우도
있다.
비정적 멤버 함수의 포인터
하지만 정적 멤버 함수가 아닌 일반 멤버 함수가 꼭 필요한 경우는 어떻게 할까,
당연히 인스턴스가 무조컨 필요한ㄴ다. 인스턴스화 된 멤버 함수는 포인터 정의도 변경해야 한다.
함수 호출은 해당 인스턴스를 통해야만 한다. instance.f는 멤버 함수 f를 호출하는 것이고
instance.*f는 f가 가리키는 멤버 함수에 접근하는 것이다.

이름 공간
초반 예제에서 std::cout을 간략히 사용하기 위해 using namespace std;를 설명했다.

게임 프로젝트에서는 몇 천개의 변수, 클래스, 함수들이 등장한다. 그러다 보면 아는 영어가 동나서 이름 짓는게
힘들어 진다. 사실, 영어권 개발자 들도 어려워 한다.
C++에서는 이러한 내부식별자들에 범위를 지정할 수 있는 이름공간을 별도록 제공한다.
사용범은 매우 간단하낟.
namespace name{}
namespace 키워드를 명시하고 이름을 지정한 다음 중괄호로 묶어 주면 된다. 이를 통해 코드 조각을 논리
단위로 구성하고 이름 충돌을 방지할 수 있다.
위와 같이 이름 공간 안에는 클래스 함수 변수 모두 사용할 수 있다. 이렇게 묶어서 Game이라는 공간을
만들어 두면 Print()처럼 다른 곳에서도 정의할 법한 일반적인 표현도 사용 가능하다.
GUI이름 공간에도 Print()가 들어 있다. 원래라면 함수 이름이 같아서 동일한 이름으로 생성할 수 없지만, 이름 공간을
사용하면 가능하다.
이름 공간이 접근하기 위해서는 범위해결연산자를 사용해야 한다. warrior같이 인스턴스화된 객체는 namespace에 
소속되어 있지 않아서 바로 사용이 가능하다. 정확히 아무 이름 공간을 지정하지 않으면 전역 이름 공간
에 포함되는 것이다.
전역 이름 공간에도 마찬가지로 명시적으로 접근할 수 있는데, ::MyFunc()과 같이 ㅈ접근할 수 있다.

일반적응로 선언과 정의는 다음과 같이 헤더와 소스파일로 나뉘서 작성한다.

using 지시자
매번 Game::를 붙이는 것이 불편할 수 ㅣㅇㅆ다. 그럴때는 using 지시문을 사용하여 이름 공간 없이 접근할 수 있다.
지금까지 자주 사용한 std::cout 역시 stdㅏㄹ는 이름 공간의 cout식별자 이다.

편리한 만큼 주의할 점도 있다.
헤더 파일에는 사용하면 안된다. 해당 헤더를 포함하는 모든 cpp파일에도 적용되어 버린다.
동일한 지역 식별자가 존재하면 구분이 됮 않아 컴파일 에러가 발생한다.
따라서 using으로 별칭을 만들거나 using namespace를 사용할 때는 헤더에서는 사용하지 않는 것이
좋다.

템플릿
지난 정렬 에제를 다시 하나 가져와 보면
그러데, float 배열을 정렬하고 싶으면? double, char은?
가장 쉽게 생각하는 방법이 SortFloat(), SortDouble()등과 같이 타입별로 함수를 구현하는 것이다.

이렇게 각 타입별로 함수 하나로 처리할 수 있다.

그런데 Monster클래스를 레벨별로 정렬한다거나 할 경우는 또 문제가 된다. 자료 구조는 얼마든지 더 많기
때문에 모두 대응하려면 계속 코드를 수정해 나가야만 한다.

C++에서는 이러한 경우를 위해 template이라는 개념을 추가했다. 타입을 일반화하여 어떠한 타입도
처리할 수 있도록 만든 다음, 프로그래머가 원하는 타입으로 특수화한다. 이러한 과정을
컴파일러가 직접 처리해 주기
때문에 타입에 신경쓰지 않고 일반화된 개념을 구현할 수 있다.

template키워드를 사용하여, 다음과 같이 지정할 수 있다.
template <typename T1, typename T2, ...>
이렇게 틀을 만들어 두면 함수나 클래스에서 T1, T2의 타입을 사용할 수 있게 되는데 이는 특정한 타입이 아니다.
템플릿 함수
템플릿 함수는 다음과 같이 선언 한다.
해당 함수를 호출할 때, 컴파일러는 T가 어떤 타입일지 자동으로 추론해서 Function을 만들어 준다.
위와 같이 호출하면 컴파일러는 template함수의 내용을 다음과 같이 구체화하여 추가해 준다.
int Function(int arg1, int arg2){}
여러 타입을 사용하다 보면 컴파일러가 추론할 수 없는 경우도 있다. 이를 대비해 명시적으로 타입을 지정할
수도 있다.
Function<float>(2.2f, 3.3f);
역시 위와 같이 함수를 호출하면 컴파일러는 다음 코드를 또 추가해 준다.
즉 템플릿을 인스턴스화 하면 할 수록 컴파일러는 계속해서 코드 내용을 추가해 버린다.
프로그래머 입장에서는 타입을 자동으로 유추한다고 보이지만 ,컴파일러는 단순히 코드를 대신 추가해줄 뿐이다.
원래 정렬 함수는 Swap()함수를 사용하여 배열의 값을 변경했는데, 간략히 하기 위해 코드를 변경하였다.
도한, 디버깅을 위해 배열을 출력하는 함수도 템플릿으로 만들었다.

템플릿 매개변수 추론
컴파일러가 주어진 값으로 추정할 수 있을 경우 다음과 같이 템플릿 매개변수를 생략해도 된다.

템플릿 클래스
RPG게임에서는 파티원이 자주 바뀔 수 있다. 전사 혼자 여행을 떠났다가 마법사를 동료로 받아들이거나 헤어지거나
하는 등, 이를 관리하려면 다형성을 이용해 Character의 목록을관리할 수 있으면 편리할 것이다.
목록의 관리는 지난 시간에 구현했던 링크드 리스트가 좋을 것 같다.
Warrior, Thied, Wizard등 플레이어가 모여 있는 리스트는 다형성을 이용해 Character 리스트로 특수화 할 수 있다.
구조체나 클래스나 기본적으로 동일하기 때문에 위와 같이 클래스 템플릿도 만들 수 있다.

템플릿 주의사항
매우 편리한 기능이지만 다음과 같은 사항을 명심해야 한다.
자동이 아니다. 많은 타입으로 특수화 하면 그 만큼 코드가 추가되는 것이다.
템플릿 선언과 정의는 같은 파일에 존재해야 한다.

이렇게 분리한 다음 빌드하면 성공한다. 아직 아무런 특수화가 이뤄지지 않았으니까,
mValue는 멤버 변수ㅏ서 선언/정의 구분이 없다. 문제가 될 만한 것은 Funcion()함수이다.

구체화가 되었을까? 아직, 컴파일러가 분석해 보니 Function을 아직 사용하지 않았다.

이제 빌드하면 함수를 찾을 수 없다고 링크 에러가 발생한다. 위 코드를 보면 함수를 사용했으니
이 함수를 특수화 해야 한다. 말이 특수화지 그냥 다음과 같은 코드를 MyClass에 추가하는 것이다.
Function(int)함수는 어디에도 정의되어 있지 않으므로 함수가 없다고 나온다.
MyClass.cpp의 구현은 버려도 되고 헤더에 다음과 같이 구현해야 한다.

명시적 생성자
이 코드는 암시적으로 MyClass c = MyClass(1)이 되어 버린다.의도 했던 것이면 상관 없지만 그렇지 않다면
헷갈리는 표기법이 되어 버린다.

이를 막기 위해서는 생성자를 명시적으로 지정하도록 explicit 키워드를 사용할 수 있다.
*/

/*
표준 라이브러리
C++ 표준 라이브러리
어떤 자료형에도 사용할 수 있는 자료구조들과 알고리즘으로 이뤄진 STL은 세계 최고듸 프로그래머들이 작성을 담당하여서
빠르고, 안정적이다. ISO표준을 따르는 C++컴파일러들은 기본적으로 STL을 내장하고 있기 때문에 별도의 설치 없이 바로 사용
할 수 있다는 편의성도 있다.

STL은 크게 다음과 같은 구성요소로 되어 있다.
컨테이너
자료구조를 위한 템플릿 클래스이다. 자료구조에서 다뤗던 Stack, Queue, List등과 같이 원소를 관리하는 집합과 같은
공간이며 다른 말로는 컬렉션이라고도 한다. 각 컨테이너 별로 장단점이 있으므로 특징을 잘 이해하고 있으면 높은 성능을 
발위할 수 이싸다.
반복자
컨테이너의 원소들을 순회하기 위한 일반화된 방법을 반복자라 한다. 반복자는 컨테이너 종속적이지 않기
때문에 언제들지 분리 결합하여 사용이 가능하다. 다음과 같은 공톤 기능이 있다.
포인터 개념 : 원소를 가르킴
원소 순회 : ++ != == 드으이 연산자 지원
시작, 끝 제공 : begin(), end()
이런 반복자를 사용하면 어떠한 컨테이너든 동일한 방법으로 순회가 가능하다.
알고리즘
정렬,검색,복사부터 구현하기 어려운 기능까지 미리 준비ㅐ 둔 알고리즘 집합이다.
기타
위 3가지가 핵심 기능이며 그 외에도 메모리 관리, 멀티 스레딩, 예외 처리등의 기능도 제공한다.

std::string
조금 더 STL의 구조와 기능을 살피기 전에 STL 사용법을 익힐 겸 가장 간단한 기능인 문자열 클래스를
먼저 살펴보자.
string은 basic_string템플릿의 char 인스턴스이다. 바이트 단위로 글자를 처리한다.
wstring은 basic_string템플릿의 wchar_t인스턴스이다. wchar은 wide character의 약자로 2바이트 이상인 유니코드
를 처ㅣ하기 위한 문자 타입니다.
std::string은 문자를 우너소로 ㅏ지는 컨테이너 이다.

문자열과 다른 타입의 변환
유용한 기능 중 하나인 문자열을 다른 타입으로 변환하는 예제다.
to_string
stoi
주의할 점은 std::string은 워낙 많이 사용되어서 표준 헤더에 포함되어 있지만, 추가된 기능인 to_string(), stoi()
등은 <string>을 포함시켜 줘야 한다.

확장 문자열
일반적인 아스키코드로는 문자를 표현하기 힘들어 추가된 개념이 확장 문자이다.
C++에는 wchar_t라는 타입으로 이러한 문자를 지원하며, 문자열을 std::wstring이다. 확장 문자열은 다른
아스키문자열과 구분하기 위해 리터럴 앞에 L""접두어를 붙여서 포기한다.

문자열 스트립
sprintf_s()함수
주어진 양식에 맞게 문자열을 출력하는 함수이다.
std::ostringstream

포멧 스트립
wsprintf_s
std::dec
std::hex
std::oct
std::fixed
std::cout.precision(5);

벡터
동적 링크드 리스트와 같은 개념이 std::vector이다. 일반 수학의 집합 개념으로 S집합의 연속된 N개의
값을 벡터라 부른다. 그런데 캐발자에게는 크기와 방향을 가진 값이라 한다.
벡터 객체는 원소의 타입을 지정해서 인스턴스화 한다.
벡터 객체는 원소들의 크기와 해당 원소들의 시퀀스를 가지고 있다.
원소들의 시퀀스는 인덱스를 이용해 접근이 가능하다.
인덱스 접근은 []연산자를 사용한다. 첨자 연산자
벡터에 대한 정의는 C++ 표준 라이브러리에 정의되어 있다.
객체의 정의는 우리가 만든 동적 배열 혹은 리스트와 매우 유사하다. 물론 이쪽이 훨씬 편리하고 기능이 많고 빠르고 안전하다.

벡터를 초기화하는 방법은 크기만 지정하느 것이다.
위 표현은 요소의 타입을 정수형으로 지정하고, 크기를 5로 지정하는 표현이다.

벡터의 크기는 size()멤버 함수를 통해 구해올 수 있다. 익숙한 for반복문을 보면 0ㅂ터 size()보다 작을
때까지 반복되는 데, 이러한 것은 수하적으로 다음과 같이 표기한다. [0 : v.size()]
대괄호[]는 포함을 의미하고 ()소괄호는 제외를 의미한다. 이렇게 한 쪽이 제외되는 시퀀스를
열린 시퀀스라고 하며 C++에서는 배열, 벡터 등에서 자주 등장하는 개념이다.

C++11 범위 기반 반복
C++11에서는 이런 열린 시퀀스를 for문에도 도입하여 매우 편리해졌다.
v에 포함된 각 x에 대해라는 뜻으로 [0 : v.size()]의 모든 첨자 연산과 동일한 표현이다.
첨자를 위한 연산이 없으며, x는 반복마다 다음 요소를 의미하게 된다. 이러한 for 문을 범위 기반
반복이라 한다. 그리고 모든 요소를 반복한다는 의미로 위에서 언급한 이터레이션으로 구분하여 부르기도 하낟.
단순 반복하면서 요소 전체를 살펴볼 필요가 있을 때 매우 유용하다.

vector의 크기 변경
벡터의 유용한 기능은 계산중에 크기를 변경할 수 있다는 점이다. 이러한 기능은 제공되는 멤버 함수 push_back()을 통해
구현된다.
vector v1{3}; 초기화 목록을 통해 초기화, 값이 3인 원소 한 개를 나타냄
vector v2(3); 정수를 받는 생성자를 호출, 벡터 생성자는 크기가 3이고 값이 기본값으로 생성

반복자
반복자는 컨테이너를 순회하기 위한 포인터라고 보면 된다. 모든 컨테이너는 반복자를 가지고 있다. 벡터의 반복자는
vector::iterator에 선언되어 있다.
반복자는 컨테이너 내부에서 선언되어 있어서 범위 해결 연산자를 사용해야 한다.
컨테이너는 템플릿 이므로 인스턴스화한 후 반복자를 가져와야 한다.
반복자를 통한 순회
반복자는 포인터이므로, 값을 가져오기 위해서는 *을 사용해야 한다.
타입이 길다
STL을 사용하면 이런 긴 타입들이 자주 나온다. 그래서 auto라는 키워드가 있다.
auto 키워드는 컴파일러가 해석할 수 있으면 해당 타입으로 자동 변환 해서 사용해 준다.
물론 컴파일러가 해석 못하면 에러가 발생한다.

알고리즘 기초


















*************************/