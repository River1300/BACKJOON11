#pragma once
/*
클래스 고급
형변환과 다형성
RPG게임 캐릭터를 만들어 보자
새로운 프로젝트를 만들고 다음과 같이 Character클래스와 Warrior클래스를 만들어 보자.
각 생성자와 초기화는 확인을 위해 각각 메시지를 출력하고 Attack역시 구분을 위해 메시지를 구분해 주면 된다.

다형성을 이용하여 Warrior인스턴스를 Character* 에 배정하여 가상 함수 Attack을 호출하였다.
그 이외에도 기반 클래스 생성자, 가상 소멸자, cosnt멤버 함수 등의 기능이 사용되었다.

전사가 레벨업을 해서 두 번 베기를 해운다. 그럼 Warrior::DoubleSlach()함수가 필요하다.
pHero->DoubleSlash()가 호출되지 않는다.
pHero는 Character*이고 가상 함수 테이블에는 Attack만 들어 있어서 찾을 수 없다.
두번 베기를 Character에 올려야 할까
안된다. 전사 전용 스킬을 Character가 가지고 있는것은 비효율 적이다. 해당 함수는
Charater에서 파생되는 수 많은 클래스 중 오직 Warrior만 사용하는 것인데 이를 일반화 시키는 것은
좋지 않는다.
이런 문제를 해결하려면 강제로 Character*에서 Warrior*로 변환해야 한다. 힙에 생성된 객체는 Warrior이므로 가능
하다.
((Warrior*)pHero)->DoubleSlach();
pHero를 명시적 형변환을 사용한 다음 위와 같이 호출이 가능하다.
지금 작성한 코드는 명확하게 pHero가 Warrior라는 것을 알지만, 복잡한 코드 속에서는 아무리
프로그래머라도 장담하기 어렵다. 가령 pHero가 다른 클래스인 경우에는 해당 프로그램은
크래시가 발생하고 말 것이다.
C++에서는 이런 위험한 상황을 막기 위해 형변환 연산자를 준비해 뒀다. 연산자에 대해 알아보기 전에
상속에서 형변환에 대해 용어를 정리하자.
상향 변환
파생 클래스 -> 기반 클래스
안전한 변환이라 암시적 변환도 충분
Character* pHero = new Warrior;

하향변환
기반 클래스 -> 파생 클래스
런타임에 체크하지 않으면 결과를 알 수 없다.
(Warrior*) pHero

staticCast
컴파일 시간에 형변환을 결정하는 연산자로 다음과 같이 사용된다.
static_cast<new type> expressios
기본적인 암시적 형변환과 구조적으로 같지만 조금더 엄격하다.
프로그래머가 어떤 타입을 어떤 타입으로 변환하는 지 명확하게 알고 있다면 정적 변환을 하용하면 된다.

형변환을 한 뒤 꼭 반환값이 정상인지 확인하기 바람
잘못된 포인터에 접근하는 것은 항상 치명적인 문제가 됨

dynamic_cast
실행시간에 동적으로 타입을 변환하는 연산자로 다음과 같이 사용된다.
dynamic_cast < new type> expression
클래스의 포인터 및 찹조형에서만 가능하며 주어진 포인터를 대상 타입의 완전히 유효한 객체에 대한 포인터로 변환흔
것을 보장한다. 실행 시간에 동적으로 판단하기 위해서는 rtti이라는 정보들이 필요한데 특정 컴파일러는 꺼져있
을 수도 있다.

비주얼 스튜디오에서는 기본으로 사용하게 되어 있으므로 큰 문제는 없을 것이지만
혹시 다른 컴파일러를 사용하면 확인해야 한다.
가장 안전함을 보장하지만, 형변환을 위해 rtti라는 추가 정보를 사용하기 때문에 성능에
영향을 줄 수 있다.

reinterpret_cast
새로 해석하다라는 단어 뜻을 지닌 만큼 어떠한 형변환도 수행하려고 하는 위험하지만 유용한 녀석이다. 객체의
자료를 바이너리 데이터로 해석한 다음 해당 타입을 ㅗ변환을 시도한다.
float f = 10.0f
std::cout<<*reinterpret_cast<int*>(&f);
명시적으로 intf를 하면 오버플로가 되지 않아 10이 되겠지만 위 변환은 완전히 다르다.
부동 소수점 표현을 위한 메모리 공간을 2진수로 변환한 다음 정수로 변환하기 때문에 예상치 못한 값이 나온다.

심지어 아무런 상관 없는 클래스도 강제로 변환한다.

주로 데이터 파일을 변환하거나 할 때 사용하는 표기법이다.

const cast
상수를 변환해 준다.
const 기호 추가도 가능하고 제거도 가능하다. 단, 포인터 및 참 조형만 가능하다.
위 예제는 컴파일러 에러, 인자로 cosnt cha*를 넘겨 주기 때문 char*로 변환이 혀용되지 않는다.
이런 경우 cosnt_cast로 const를 제거하는 변환을 할 수 있다.
Pirnt(const_cast<char*>(myString));


추상 클래스
RPG캐릭터로 돌아가 이번에는 몬스터를 추가해 보자.
플레이어가 조작하는 전사와 새로 추가할 악마와 늑대 몬스터
각각 기능을 정리해 놓고 보면 다음과 같이 묶을 수 있다.

전사든 악마든 늑대든 모두 필수적으로 공격 사망 을 처리해야만 한다.
앞으로 추가되는 직업이나 몬스터 역시 모두 반드시 필요한 것이다.
위와 같이 어떤 객체를 표현할 때, 기반 클래스에서 공통된 기능을 잘 정리해 두는 것이 좋다.

그런데 사실 Character의 공격 사망은 의미가 없다. Character는 단순한 공통 개념일 뿐이다.
따라서 함수에서는 아무것도 안해도 된다.

생성자/소멸자 확인을 위한 코드는 지금은 의미가 없어서 모두 삭제하고 빈 함수로 다시 만든다.
Character.cpp의 내용ㅇ느 모두 지운다.
이 클래스는 스스로는 어떠한 연산을 수행하지 않지만 Character에서 파생되는 클래스들에게 일종의
약속을 만들어 준다.
Character상속 받으려면 Attack(), Dead()를 꼭 구현

이미 만들어둔 Warrior는 Attack()과 DoubleSlach만 구현했고 Dead는 없다.
당연히 컴파일은 성공핟낟 기반 클래스의 가상 함수를 상속하지 않아도 인스턴스를 만들 수 있다.

순수 가상 함수
하지만 조금 더 엄하게 규격을 정하고 싶을것, 캐릭터의 공격 사망 루틴이 없으면 의미가 없으므로 반드시 만들
어야 상속을 받을 수 있다고, 이런 것을 pure virtual function이라 한다.

위와 같이 가상 함수 선언 뒤에 =0을 붙여 주면 이 함수는 순수 가상 함수라는 의미가 된다.
순수 가상 함수는 해당 함수를 상속받아서 정의하지 안으면 인스턴스를 만들 수 없게 해준다.
위와 같이 수정한 다음 빌드를 해보면 추상 클래스를 인스턴스화 할 수 없다.

이렇게 순수 가상함수들로만 이루어진 클래스는 약속이외의 어떠한 역할도 하지 않는다.
이러한 클래스를 추상 기반 클래스라 부른다.
추상 클래스 자체로는 인스턴스도 만들 수 있다.

이렇게 순수 가상 함수들로만 이루어진 클래스는 약속이외의 어떠한 역할도 하지 안흐나다.
이러한 클래스를 추상 기반 클래스라 부른다.
추상 클래스 자체로는 인스턴스도 만들 수 없다.

추상 클래스 : 순수 가상 함수를 하나라도 가지고 있는 클래스
	인스턴스 불가
	기반 클래스로만 사용할 것
	파생 클래스는 모든 순수 가상 함수를 오버라이딩
*/

/*
멤버 함수의 포인터
멤버 함수의 포인터에 대해 설명하기 전에, 우선 기존 함수 포인터를 정리해 보자.
int(*f)(int x)
위 표현은 반환값 int를 가지고 int를 매개변수로 하는 함수 포인터의 의미가 된다. int* f(int x)는 완전히
다른 의미이므로 괄호에 주의
이런 표현은 한눈에 보기도 힘들뿐 반복해서 타이핑 하기 불편하다. 편리하게 만드는 것부터 시작하면
타입을 재정의 하는 것은 typedef와 using을 통해 살펴 봤었는데 이를 사용하면 함수 포인터 역시
간단히 재정의 가능하다.
typedef typedef int (*FunctionPtr) (int);
using using FunctionPtr = int(*)(int);
훨씬 보기 좋고 편리한 것은 using,
int Sigma(FunctionPtr f, int m , int n){}

정적 멤버 함수의 포인터
당연히 에러가 발생, 함수를 구현할 때는 다음과 같이 클래스에 속한 것들은 클래스에 속한 것이라고 알려 줬다.
범위 해결 지정자:: 를 사용해서 클래스에 속해 있다고 알려줬다.
int MyFunctions::NormalFunction(int x){}
에러가 발생 한다.
문법적으로 표준이 아니라는 의미로 올바른 표현을 써 달라는 것, 일반 함수는 암시적으로 자동적으로 함수 포인터
로 변환되ㅣㅈ만 멤버 함수는 그렇지 않기 때문에 멤버 함수의 주소를 넘겨 줘야 한다.
멤버 함수를 변환할 수 없다는 군, 클래스의 의미를 다시 생각해 보면, 실제 클래스는 인스턴스화 되지 않으면 아무런
의미가 없다.인스턴스화 하지 않고 객체에 접근하는 방법은 정적 멤버 밖에 없다.

멤버 함수 포인터를 사용할 때 정적 멤버 함수를 사용하는 것, 이런 식으로 비록 클래스이지만 연산들만으로 구성하는 경우도
있다.
비정적 멤버 함수의 포인터
하지만 정적 멤버 함수가 아닌 일반 멤버 함수가 꼭 필요한 경우는 어떻게 할까,
당연히 인스턴스가 무조컨 필요한ㄴ다. 인스턴스화 된 멤버 함수는 포인터 정의도 변경해야 한다.
함수 호출은 해당 인스턴스를 통해야만 한다. instance.f는 멤버 함수 f를 호출하는 것이고
instance.*f는 f가 가리키는 멤버 함수에 접근하는 것이다.

이름 공간
초반 예제에서 std::cout을 간략히 사용하기 위해 using namespace std;를 설명했다.

게임 프로젝트에서는 몇 천개의 변수, 클래스, 함수들이 등장한다. 그러다 보면 아는 영어가 동나서 이름 짓는게
힘들어 진다. 사실, 영어권 개발자 들도 어려워 한다.
C++에서는 이러한 내부식별자들에 범위를 지정할 수 있는 이름공간을 별도록 제공한다.
사용범은 매우 간단하낟.
namespace name{}
namespace 키워드를 명시하고 이름을 지정한 다음 중괄호로 묶어 주면 된다. 이를 통해 코드 조각을 논리
단위로 구성하고 이름 충돌을 방지할 수 있다.
위와 같이 이름 공간 안에는 클래스 함수 변수 모두 사용할 수 있다. 이렇게 묶어서 Game이라는 공간을
만들어 두면 Print()처럼 다른 곳에서도 정의할 법한 일반적인 표현도 사용 가능하다.
GUI이름 공간에도 Print()가 들어 있다. 원래라면 함수 이름이 같아서 동일한 이름으로 생성할 수 없지만, 이름 공간을
사용하면 가능하다.
이름 공간이 접근하기 위해서는 범위해결연산자를 사용해야 한다. warrior같이 인스턴스화된 객체는 namespace에 
소속되어 있지 않아서 바로 사용이 가능하다. 정확히 아무 이름 공간을 지정하지 않으면 전역 이름 공간
에 포함되는 것이다.
전역 이름 공간에도 마찬가지로 명시적으로 접근할 수 있는데, ::MyFunc()과 같이 ㅈ접근할 수 있다.

일반적응로 선언과 정의는 다음과 같이 헤더와 소스파일로 나뉘서 작성한다.

using 지시자
매번 Game::를 붙이는 것이 불편할 수 ㅣㅇㅆ다. 그럴때는 using 지시문을 사용하여 이름 공간 없이 접근할 수 있다.
지금까지 자주 사용한 std::cout 역시 stdㅏㄹ는 이름 공간의 cout식별자 이다.

편리한 만큼 주의할 점도 있다.
헤더 파일에는 사용하면 안된다. 해당 헤더를 포함하는 모든 cpp파일에도 적용되어 버린다.
동일한 지역 식별자가 존재하면 구분이 됮 않아 컴파일 에러가 발생한다.
따라서 using으로 별칭을 만들거나 using namespace를 사용할 때는 헤더에서는 사용하지 않는 것이
좋다.

템플릿
지난 정렬 에제를 다시 하나 가져와 보면
그러데, float 배열을 정렬하고 싶으면? double, char은?
가장 쉽게 생각하는 방법이 SortFloat(), SortDouble()등과 같이 타입별로 함수를 구현하는 것이다.

이렇게 각 타입별로 함수 하나로 처리할 수 있다.

그런데 Monster클래스를 레벨별로 정렬한다거나 할 경우는 또 문제가 된다. 자료 구조는 얼마든지 더 많기
때문에 모두 대응하려면 계속 코드를 수정해 나가야만 한다.

C++에서는 이러한 경우를 위해 template이라는 개념을 추가했다. 타입을 일반화하여 어떠한 타입도
처리할 수 있도록 만든 다음, 프로그래머가 원하는 타입으로 특수화한다. 이러한 과정을
컴파일러가 직접 처리해 주기
때문에 타입에 신경쓰지 않고 일반화된 개념을 구현할 수 있다.

template키워드를 사용하여, 다음과 같이 지정할 수 있다.
template <typename T1, typename T2, ...>
이렇게 틀을 만들어 두면 함수나 클래스에서 T1, T2의 타입을 사용할 수 있게 되는데 이는 특정한 타입이 아니다.
템플릿 함수
템플릿 함수는 다음과 같이 선언 한다.
해당 함수를 호출할 때, 컴파일러는 T가 어떤 타입일지 자동으로 추론해서 Function을 만들어 준다.
위와 같이 호출하면 컴파일러는 template함수의 내용을 다음과 같이 구체화하여 추가해 준다.
int Function(int arg1, int arg2){}
여러 타입을 사용하다 보면 컴파일러가 추론할 수 없는 경우도 있다. 이를 대비해 명시적으로 타입을 지정할
수도 있다.
Function<float>(2.2f, 3.3f);
역시 위와 같이 함수를 호출하면 컴파일러는 다음 코드를 또 추가해 준다.
즉 템플릿을 인스턴스화 하면 할 수록 컴파일러는 계속해서 코드 내용을 추가해 버린다.
프로그래머 입장에서는 타입을 자동으로 유추한다고 보이지만 ,컴파일러는 단순히 코드를 대신 추가해줄 뿐이다.
원래 정렬 함수는 Swap()함수를 사용하여 배열의 값을 변경했는데, 간략히 하기 위해 코드를 변경하였다.
도한, 디버깅을 위해 배열을 출력하는 함수도 템플릿으로 만들었다.

템플릿 매개변수 추론
컴파일러가 주어진 값으로 추정할 수 있을 경우 다음과 같이 템플릿 매개변수를 생략해도 된다.

템플릿 클래스
RPG게임에서는 파티원이 자주 바뀔 수 있다. 전사 혼자 여행을 떠났다가 마법사를 동료로 받아들이거나 헤어지거나
하는 등, 이를 관리하려면 다형성을 이용해 Character의 목록을관리할 수 있으면 편리할 것이다.
목록의 관리는 지난 시간에 구현했던 링크드 리스트가 좋을 것 같다.
Warrior, Thied, Wizard등 플레이어가 모여 있는 리스트는 다형성을 이용해 Character 리스트로 특수화 할 수 있다.



















*******************/