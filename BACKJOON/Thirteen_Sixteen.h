#pragma once
/*
클래스 고급
형변환과 다형성
RPG게임 캐릭터를 만들어 보자
새로운 프로젝트를 만들고 다음과 같이 Character클래스와 Warrior클래스를 만들어 보자.
각 생성자와 초기화는 확인을 위해 각각 메시지를 출력하고 Attack역시 구분을 위해 메시지를 구분해 주면 된다.

다형성을 이용하여 Warrior인스턴스를 Character* 에 배정하여 가상 함수 Attack을 호출하였다.
그 이외에도 기반 클래스 생성자, 가상 소멸자, cosnt멤버 함수 등의 기능이 사용되었다.

전사가 레벨업을 해서 두 번 베기를 해운다. 그럼 Warrior::DoubleSlach()함수가 필요하다.
pHero->DoubleSlash()가 호출되지 않는다.
pHero는 Character*이고 가상 함수 테이블에는 Attack만 들어 있어서 찾을 수 없다.
두번 베기를 Character에 올려야 할까
안된다. 전사 전용 스킬을 Character가 가지고 있는것은 비효율 적이다. 해당 함수는
Charater에서 파생되는 수 많은 클래스 중 오직 Warrior만 사용하는 것인데 이를 일반화 시키는 것은
좋지 않는다.
이런 문제를 해결하려면 강제로 Character*에서 Warrior*로 변환해야 한다. 힙에 생성된 객체는 Warrior이므로 가능
하다.
((Warrior*)pHero)->DoubleSlach();
pHero를 명시적 형변환을 사용한 다음 위와 같이 호출이 가능하다.
지금 작성한 코드는 명확하게 pHero가 Warrior라는 것을 알지만, 복잡한 코드 속에서는 아무리
프로그래머라도 장담하기 어렵다. 가령 pHero가 다른 클래스인 경우에는 해당 프로그램은
크래시가 발생하고 말 것이다.
C++에서는 이런 위험한 상황을 막기 위해 형변환 연산자를 준비해 뒀다. 연산자에 대해 알아보기 전에
상속에서 형변환에 대해 용어를 정리하자.
상향 변환
파생 클래스 -> 기반 클래스
안전한 변환이라 암시적 변환도 충분
Character* pHero = new Warrior;

하향변환
기반 클래스 -> 파생 클래스
런타임에 체크하지 않으면 결과를 알 수 없다.
(Warrior*) pHero

staticCast
컴파일 시간에 형변환을 결정하는 연산자로 다음과 같이 사용된다.
static_cast<new type> expressios
기본적인 암시적 형변환과 구조적으로 같지만 조금더 엄격하다.
프로그래머가 어떤 타입을 어떤 타입으로 변환하는 지 명확하게 알고 있다면 정적 변환을 하용하면 된다.

형변환을 한 뒤 꼭 반환값이 정상인지 확인하기 바람
잘못된 포인터에 접근하는 것은 항상 치명적인 문제가 됨

dynamic_cast
실행시간에 동적으로 타입을 변환하는 연산자로 다음과 같이 사용된다.
dynamic_cast < new type> expression
클래스의 포인터 및 찹조형에서만 가능하며 주어진 포인터를 대상 타입의 완전히 유효한 객체에 대한 포인터로 변환흔
것을 보장한다. 실행 시간에 동적으로 판단하기 위해서는 rtti이라는 정보들이 필요한데 특정 컴파일러는 꺼져있
을 수도 있다.

비주얼 스튜디오에서는 기본으로 사용하게 되어 있으므로 큰 문제는 없을 것이지만
혹시 다른 컴파일러를 사용하면 확인해야 한다.
가장 안전함을 보장하지만, 형변환을 위해 rtti라는 추가 정보를 사용하기 때문에 성능에
영향을 줄 수 있다.

reinterpret_cast
새로 해석하다라는 단어 뜻을 지닌 만큼 어떠한 형변환도 수행하려고 하는 위험하지만 유용한 녀석이다. 객체의
자료를 바이너리 데이터로 해석한 다음 해당 타입을 ㅗ변환을 시도한다.
float f = 10.0f
std::cout<<*reinterpret_cast<int*>(&f);
명시적으로 intf를 하면 오버플로가 되지 않아 10이 되겠지만 위 변환은 완전히 다르다.
부동 소수점 표현을 위한 메모리 공간을 2진수로 변환한 다음 정수로 변환하기 때문에 예상치 못한 값이 나온다.

심지어 아무런 상관 없는 클래스도 강제로 변환한다.

주로 데이터 파일을 변환하거나 할 때 사용하는 표기법이다.

const cast
상수를 변환해 준다.
const 기호 추가도 가능하고 제거도 가능하다. 단, 포인터 및 참 조형만 가능하다.
위 예제는 컴파일러 에러, 인자로 cosnt cha*를 넘겨 주기 때문 char*로 변환이 혀용되지 않는다.
이런 경우 cosnt_cast로 const를 제거하는 변환을 할 수 있다.
Pirnt(const_cast<char*>(myString));


추상 클래스
RPG캐릭터로 돌아가 이번에는 몬스터를 추가해 보자.
플레이어가 조작하는 전사와 새로 추가할 악마와 늑대 몬스터
각각 기능을 정리해 놓고 보면 다음과 같이 묶을 수 있다.

전사든 악마든 늑대든 모두 필수적으로 공격 사망 을 처리해야만 한다.
앞으로 추가되는 직업이나 몬스터 역시 모두 반드시 필요한 것이다.
위와 같이 어떤 객체를 표현할 때, 기반 클래스에서 공통된 기능을 잘 정리해 두는 것이 좋다.

그런데 사실 Character의 공격 사망은 의미가 없다. Character는 단순한 공통 개념일 뿐이다.
따라서 함수에서는 아무것도 안해도 된다.

생성자/소멸자 확인을 위한 코드는 지금은 의미가 없어서 모두 삭제하고 빈 함수로 다시 만든다.
Character.cpp의 내용ㅇ느 모두 지운다.
이 클래스는 스스로는 어떠한 연산을 수행하지 않지만 Character에서 파생되는 클래스들에게 일종의
약속을 만들어 준다.
Character상속 받으려면 Attack(), Dead()를 꼭 구현

이미 만들어둔 Warrior는 Attack()과 DoubleSlach만 구현했고 Dead는 없다.
당연히 컴파일은 성공핟낟 기반 클래스의 가상 함수를 상속하지 않아도 인스턴스를 만들 수 있다.

순수 가상 함수
하지만 조금 더 엄하게 규격을 정하고 싶을것, 캐릭터의 공격 사망 루틴이 없으면 의미가 없으므로 반드시 만들
어야 상속을 받을 수 있다고, 이런 것을 pure virtual function이라 한다.

위와 같이 가상 함수 선언 뒤에 =0을 붙여 주면 이 함수는 순수 가상 함수라는 의미가 된다.
순수 가상 함수는 해당 함수를 상속받아서 정의하지 안으면 인스턴스를 만들 수 없게 해준다.
위와 같이 수정한 다음 빌드를 해보면 추상 클래스를 인스턴스화 할 수 없다.

이렇게 순수 가상함수들로만 이루어진 클래스는 약속이외의 어떠한 역할도 하지 않는다.
이러한 클래스를 추상 기반 클래스라 부른다.
추상 클래스 자체로는 인스턴스도 만들 수 있다.

이렇게 순수 가상 함수들로만 이루어진 클래스는 약속이외의 어떠한 역할도 하지 안흐나다.
이러한 클래스를 추상 기반 클래스라 부른다.
추상 클래스 자체로는 인스턴스도 만들 수 없다.

추상 클래스 : 순수 가상 함수를 하나라도 가지고 있는 클래스
	인스턴스 불가
	기반 클래스로만 사용할 것
	파생 클래스는 모든 순수 가상 함수를 오버라이딩





*/