#pragma once
/*
복잡한 형식들

Type Conversion(형식 변환)
타입과 객체
타입에 대해 다시 한번 정리해 보자.
	타입은 해당 객체의 사용 가능한 값과 적용할 수 있는 연산을 정의한다.
	객체는 주어진 타입의 값을 저장하는 메모리 공간이다.
	값은 주어진 타입으로 메모리 공간의 비트 집합을 해석한 것이다.
	변수는 객체에 이름을 붙여 둔 것이다.
	선언(declaration)은 객체의 이름을 지정하는 구문
	정의(definition)은 객체의 메모리 공간을 할당하는 일존의 선언
컴퓨터의 메모리 공간은 항상 비트구조로 되어있습니다. 어떤 타입의 값을 저장하더라도 컴퓨터에는 비트와되어있다.
즉 타입이 없다면 그 값이 무엇인지 알지 못한다.
현실을 예로 들면 10이라는 숫자 자체는 아무런 의미도 없지만 거기에 10원 10kgm 10m등 어떤 단위가
붙어야 그 숫자가 의미를 가지게 되는 것처럼 변수도 타입에 의해 의미를 가지게 된다.

마찬가지로 RAM에 할당된 다음 값은 그 자체로는 아무 의미가 없다. 01001000
위 메모리를 int로 접근하면 2진수를 10진수로 변환한 72가된다. 하지만 char로 접근하여 '0'이라는 문자가 된다.
타입의 규칙에 따라 객체를 이용하는 것을 타입안정성이라고 부르는다. C++는 편의성읠 위해 완전한 타입 안정성을
보장하지 안는다. 프로그래밍을 하다보면 타입을 변환하게 되는 경우가 있다.

int a = 1;
std::string myString = a;
변수를 설명할 떄 특정 형식을 저장하기 위해 형식을 지정한다고 했으며, 서로 다른 형식은 저장할 수 없다고
했으므로 위 예제는 컴파일이 되지 않는다. 정수형을 문자열형에 배정하려고 했는데, 이러한 표현이 허용되지 않는다.

int a = 1;
long long x = a;
위 예제는 int(4 byte)형을 long long(8 byte)형에 대입했는데, 정상적으로 컴파일이 되며 아무련 에러도 없다.
이러한 것을 형식 변환이라고 부르며, 위 예제에서는 자체적으로 변환이 일어나서 int가 long long으로 변환된다.
크기가 작은 것에서 큰 것으로 변환은 안전하게 변환된다.

int a = 1024;
char x = a;
하지만 int(4byte)에서 char(1byte)처럼 저장 공간이 큰 것을 작은 것으로 변환하면 값이 잘려나갈 수 값에 없다.
이러한 것을 축소변환(narrow conversion)이라고 부르며 프로그램에서 알 수 없는 에로의 주범이 되기도 한다.

int a = 1024;
char x{a};

정수와 실수를 변활 할 때는 항상 주의해야 한다. 실수를 정수로 변환하면 소수점 아래가 전부 잘려나간다.
int value = 1.6; -> 1
int a= 10
int b = 3;
int c = a/b -> 3

암시적 변환 혹은 묵시적 변환
기본적으로 타입 변환의 원식은 정보 손실을 최소화 할 수 있는 방향으로 수행한다는 것이다. 정보 손실은 저장 공간
이 큰 값에서 작은 값으로 이동할 때 발생하는 것이 기본이지만 정수와 실수에서도 발생한다.

이런 자동적인 타입 변환을 암시적 변환이라ㅗ 부르며 혼란의 요지가 될 가능성이 높다. 따라서 연산을 작성할 때는
의도를 명시적으로 표현하는 것이 좋다.

int(1.5f);
int{1.5f};
static_cast<int>(1.5f);
정수와 실수의 연산을 항상 이러한 타입 변환을 염두에 두고 작성합니다.

암시적 형변환
	컴파일러가 허용하는 형변환으로 프로그래머가 특별한 작업을 하지 않아도 자동적으로 변환이 일어난다.
	형식에서 각 형시의 크기를 살펴 봤는데, 그 크기가 작은 것에서 큰 것으로으 ㅣ변환은 대부분 허용

명시적 형변환 프로그래머가 직접 지정하는 형변환으로 Type cast라고 부른다.
	변환 하려는 형식 앞에 (형식)을 붙여서 변시적으로 표현한다.
	큰 형식으서 작은 형식으로 변환하면 저장공간의 크기 때문에 값이 잘려나간다.
	명시적으로 표시해도 불가능한 캐스팅이 있다.

int myInteger = 1000;
unsigned char myCharacter = myInteger;

std::cout<<myInteger<<std::endl;
std::cout<<int(myCharacter)<<std::endl;
명시적으로 형변환을 위해 (byte)라는 것을 붙여줬고, 에러 없이 실행이 가능하다. 출력 결과는 1000과 232이다.

형식의 크기가 작아서 작려 나갔다는 것은 알겠는데, 어떻게 잘린 것인지 살펴 보기 위해 각 결과를 2진수로 표기해 보자

1000(10) = 0011 1110 1000
 232(10) =      1110 1000
 결과를 잘 보면 unsigned char는 8bit 표현 범위를 가지므로 8자리만 저장할 수 있으므로 ,입력된 값의 오른쪽에서
 8개 비트만 저장되고 나머지는 잘려 나간다. 이렇게 형식의 저장공간에 따라 값이 잘려나간다.

 별칭(alias)
 unsigned int와 같은 타입은 매우 길어서 사용할 때 매우 귀찬다. 컴파일러는 프로그래머를 조금 더 편리하게
 만들어 주기 위해 별칭이라는 기능을 제공하낟. 자주 사용되는지 않지만 알고 넘어가자
 typedef 기존 형식 별칭;
 typedef unsigned int uint;
 uint a = 1;
using 별칭 = 기존 형식;
using uint = unsined int;
uint a =1;

typedef와 별칭/형식 순서가 다르다. using 은 단순한 타입 이외에도 다양한 기능이 존재하므로 매우 편리한다.
using namespace std

열거형
지금까지 살펴본 형식들은 정수 문자열등 단순한 형식이다. 이번에는 좀더 복잡하지만 유용한 형식들에 대해
알아보자.
RPG의 공격 데미지 타입을 한번 생각해 보자. 이 형식은 공격 타입{ 물리, 마법, 고정 }으로 정의할 수 있다.
그런데 이런 형식은 C++언어에는 없다.

열거형식은 집합타입으로 새로운 형식을 정의하고 정의한 타입으로 다른 형식처럼 변수를 선언해서 사용하면 된다.
enum 집합타입
{
	원소1,
	원소2,
	...
	원소n
};

enum AttackType { Physical, Magical, Fixed };
AttackType type = Physical;

switch(type)
	case Physical:
		break;
	case Magical:
		break;
	case Fixed:
		break;
열거형은 내부적으로 정수형이다. 즉, Physical은 0, Magical은 1, Fixed는 3이된다.
그래서 열거형은 명시적 형변환을 통해 성수로 변환이 가능하다. 반대로 정수형에서 명시적으로 열거형으로 변환도 된다.

열거형은 다음과 같이 각각 값을 지정해 줄 수 있다. 사용범을 생향하면 자동으로 0부터 시작한다.
enum 집합타입
	원소1 = 값;
	원소2 = 값,
	...
색상 표현이 16진수로 되어있는데 이또한 열거형으로 편리하게 가능하다.
enum Color
	Red = 0xFFFF0000,
	Magenta = 0xffff00ff,
	Pink = 0xffffc0cb,
지금까지 살펴 본 특징을 통해 이미 눈치 챘겠지만 이러한 열거형은 상수라는 점을 기억하라.

플래그
플래그라는 용어, 복선, 암시를 나타내기 위한 단어, 프로그래머 용어이다.
가령 RPG게임에서 보조 퀘스트 4개의 클리어 여부를 저장한다고 가정하면 각 퀘스트는 필수가 아니므로 선택적으로
클리어가 가능할 텐데, 5번째 보조퀘스트는 1,3번 퀘스트를 수행해야만 열린다고 생각해 보세요. 프로그램에는 각
각 퀘스트의 클리어 정보가 있어야 하는데, 어떻게 구성하는 것이 좋을까
bool quest1 = false;
bool quest2 = false;
bool quest3 = false;
bool quest4 = false;
if(quest1 && quest3) 5번 퀘스트 시작
퀘스트가 4개 더 추가되면? 코딩이 엄청 복잡해 질거다.

다음과 같은 4비트 공간을 가정해 보자. 각 비트는 서로 독립되어 있어서 비트별로 다른 특성을 부여할 수 있다.
따라서 각 비트를 퀘스트의 클리어 여부로 사용할 수 있다.
0 0 0 0
이렇게 각 비트가 독립적인 상태를 나타내는 것을 깃발과 같다고 하여 만들어진 개념이 flag이다.
int questComplete{0};
questComplete |= 1;
questComplete |= 4;

if(questComplete & 1 && questComplete & 4) 5번 퀘스트 시작
비트 연산으로 4개의 플래그를 정수 하나에 담는다. 1과 4는 정수 리터럴이라 헷갈릴 수 있어더 다음과 같이 표현하기도 한다.
quest |= 0x01;
quest |= 0x04;
quest |= 0b0001;
quest |= 0b0100;
enum QuestCleared
	quest1 = 0b0001,
	quest2 = 0b0010,
	quest3 = 0b0100,
	...
단 주의할 점은 enum 자체에 quest1 | quest3 = 0b0101은 정의되어 있지 않는다. 따라서 정수로 값을 저장하는 것에 
주의해야 한다.

구조체
가령 RPG게임에서 플레이어는 다음과 같은 능력치 정보를 가지고 있다.
체력, 마력, 힘, 마법, 방어력 등
이런 능력치 정보를 각각 개별 정보로 사용해도 되지만 ,하나의 형식처럼 묶을 수 있다면 더 효율적으로 
만들 수 있다. 5인 파티로 구성된 게임이면 위와 같은 변수를 HP1, HP2, HP3,... 과 같이 5벌씩 만들어야 한다.

이런 경우를 위해 구조체라는 개념이 있다.
struct 형식이름
	형식 멤버1;
	형식 멤버2;
위와 같이 struct 형식이름을 선언해주고 블록으로 멤버들을 정의해주면 된다.
struct Ability
	int HP;
	int MP;
	int strength;
	int magic;
	int defense;

struct Ability warriorAbility;

warrioAbility.HP = 10000;
warriorAbility.MP = 0;
...
struct Ability 구조체 Ability형을 선언한다.
struct Ability warriorAbility;
가장 앞에 struct키워드를 붙이고 일반 변수 선언과 동일하게 "형식명 변수명"을 사용한다.
전사 클래스의 능력치에 대한 구조체이다.
구조체의 각 멤버에 값을 집어 넣는다. 형식 이름.멤버와 같은 형식으로 점 연산자를 사용하여 접근한다.
warriorAbility.HP = 100;
구조체는 다음과 같이 선언과 동시에 정의도 가능하다.
struct Ability
	int HP;
	...
} warrior, magicioa, thief,...
주의할 점은 구조체는 형식(type)이라는 것이다. 
Ability.HP = 10 / int = 10
구조체 역시 변수로 만들고 사용할 수 있다.

구조체 선언 방법
위에서 살펴본 선언이외에 다양한 스타일이 존재한다.

구조체 초기화
구조체를 초기화하려면 위에서 언급한대로 간단히 구조체 타입의 객체를 만들고 점 연산자를 통해 멤버들에 값을 지정하면 된다.
struct stat mageS;
mageS.HP = 100;
mageS.MP = 1000;
...
귀찬으닌 C++11 이후부터 나온 유니폼 초기화를 사용하다.
stat mageS{100,1000,10,10,10,10};
값의 순서는 구조체에 선언한 멤버 변수들의 순서이다.
다음과 같이 멤버들의 일부만 초기화하고 나머지는 기본값을 사용할 수도 있다.
stat mageS{10,10};

초기값 기본적으로 기본값으로 초기화 됩니다. 정수형의 초기값은 0이기 때문에 구조체가 0으로 초기화 되는 것입니다.
만약 초기값을 다른 것으로 지정하려면? 구조체를 선언할 떄 다음과 같이 멤버에 지정해 둘 수도 있다.
struct stat
	int HP{100};
	int MP{10};
	int ...
	...
당연히 구조체 선언에 사용된 초기값이 있다고 하더라도, 구조체 변수를 선언할 떄 넘겨준 ㅏㅄ이 있으면 해당 값으로
초기화 된다.

구조체 수정
구조체 멤버들을 수정하기 위해서는 마찬가지로 점 연산자를 통해 개별 멤버 변수에 값을 대입하면되나.ㄷ
하지만 일괄적으로 변경할 경우에는?
이때도 마찬가지로 유니폼 초기화 식을 사용할 수 있다.
mageS = {10000,10001,1001} / mageS = stat{1000,10101,1011,10};
위 표기는 사싱 다음과 같은 표기를 간략하게 표현하기 위해 생략한 것이다.
즉 새로운 stat오브젝트를 초기화한뒤 해당 오브젝트에 대입, 즉 복사한 것이라 복수 있다.
그리고 다른 오브젝트의 값을 그대로 복사해서 초기화 하는 것도 가능하낟.
stat cloneA{mageS};
이 코드는 mageS의 모든 멤버를 cloneA로 복사 생성한 것이다.
*/

/*
배열
지금까지의 변수는 하나에 하나의 값만을 가지고 있다. 가령 슈팅 게임에서 상위 10명의 하이스코어를
저장하는 경우, int score1, int score2, int score3 ...이런 식으로 동일한 형식의 값을 여러 개 저장
할 경우에는 사용할 수 있는 배열이 있다.
형식 변수명[크기];
변수명[인덱스]=값;
	변수명 뒤에 대괄호를 붙여 주고 크기를 지정하면 배열로 선언이 가능하다.
	값을 가져오거나 사용할 떄는 변수명 뒤에 대괄호로 인덱스를 지정해 줘야 한다.
	인덱스는 0 기준

int scores[10];

for(int i=0;i<10;i++)
	std::cout<<"INPUT score[" << i<<"] : ";
	std::cin>>scores[i];

for(int i=0;i<10;i++)
	std::cout<<i<<" : "<<scores[i]<<'\n';

int scores[10]; 정수형 10개를 한 묶으로 하는 배열 변수를 선언한다.
cin>> scores[i]; 키보드 입력으로 변수를 입력 받아 배열 저장한다. 배열에 접근하기 위해서 인덱스[]를 명시한다.
0 ~ 9까지 총 10번 반복한다.

첨자로 인덱스 지정하기
인덱스를 지정할 떄는 다음과 같이 다양하게 지정이 가능하다.
리터럴 scores[0]
상수 및 열거형 scores[Red];
변수 scores[x];
표현식 scores[x+1];

배열의 크기 지정하기
배열 첨자는 다양한 형태로 지정이 가능하지만, 배열을 선언할 떄 크기는 상수만 가능하다.
리터럴 int scores[3];
상수 및 열거형 const int arrayLength = 3; int scores[ArrayLength];
변수는 불가능

int scores[]배열을 준비할 때 그 크기를 명확하게 알 수 없으면 배열을 준비할 수 없다.
x자체가 변수라서 다른 곳에서 변경될 위험도 있기 때문에 문법상 허용하지 않는다.
배열은 실행할 떄 결정되는 것이 아니라 컴파일 될 때 미리 준비하는 것이다. 컴파일 타임 상수가 필요하다.

초기화 되지 않은 값
int scores[10];
for(int i=0;i<10;i++)
	std::cout<<i<<" : "<<scores<<'\n';
이번 예제는 배열을 정의한 뒤 바로 값을 출력해 보자.
기본적으로 변수들은 정의된 후 어떤 값도 저장되어 있지 않다. 정확하게는 전에도 언급한 쓰레기값이
들어있다.
변수들은 RAM에 자리잡고 있는데, 효율적인 관리를 위해 변수가 사라질 때 지우거나 하지않는다.
단순히 해당 객체의 이름과 연결되 어있는 공간의 연결만 끊어 주는 것이다. 따라서 새로 객체를 만들면 해당
메모리에는 이전에 사용한 혹은 다른 프로그램이 사용했던 값이 남아 있을 수도 있는데 이를 쓰레기 값이라 한다.

배열 초기화
유니폼 초기화를 사용하면 간단히 배열을 초기활 할 수 있다.
int scores[10]{1,2,3,4,5,6,7,8,9,10};
int scores[10]{1,2,3};
int scores[10]{};

int scores[10]{};
for(int i=0;i<10;i++)
	std::cin>>scores[i];
int totalScore{};
for(int i=0;i<10;i++)
	totalScore += scores[i];
std::cout<<"Total : "<<totalScore<<'\n';

구조체와 배열
struct Point2D
	double x; double y;

Point2D pts[3];
pts[0].x = 1.1;
pts[0].y = 1.1;
구조체 멤버에 접근하기 위해서 []기호로 배열의 우너소에 먼저 접근한 다음 점 연산자를 사용해한다.

다차원 배열
만약, 엑셀처럼 가로(행), 세로(열)이 있는 값은 어떻게 해야 하나?
int myArray[15] = {
	0, 0, 1, 0, 0,
	0, 1, 1, 1, 0,
	1, 1, 1, 1, 1, };
for(int i=0; i<15; i++)
	std::cout<<myArray[i];
	if((i+1)%5==0)
		std::cout<<'\n';
배열에 값을 순서대로 집어 넣어 출력한다. 다만 위 엑셀표는 5열로 되어 있느니, 5의 배수 마다 줄바꿈 하줘야 한다.

i행 j열의 값을 구하세요.
[(i - 1) * 5 + (j - 1)] 

2차원 배열
그래서 인덱스가 2개인 행렬을 표기하기 위해 2차원 배열이 있다.
int myArray[3][5] = {
	{0,0,1,0,0},
	{0,1,1,1,0},
	{1,1,1,1,1} };

for(int i=0; i<3;i++)
	for(int j=0; j<5;j++)
		std::cout<<myArray[i][j];
	std::cout<<'\n';
int myArray[3][5] = 
2차원 배열은 배열의 배열이라는 개념으로 배열 뒤에 다시 배열을 붙여서 [][]표기한다.
크기를 지정할 때는 [행,열]과 같이 지정하면 된다.
초기 값은 행/열 순으로 기입한다. 중괄호로 하나으 ㅣ행을 묶어서 표기하고, 쉼표로 구분해서 열을 표기한다.

이렇게 인덱스 차원이 하나인 배열을 1차원 배열이라고 부르며 인덱스가 2개인 배열을 2차우너 배열이라고 부른다.
3차원 4차원도 가능하다.

좌측값 우측값
배정문을 설명할 떄 기본적으로는 연산자의 좌측을 lvalue, 오른쪽을 rvalue라고 설명했다.
int x;
x = 3 + 4;
위 표현에서 x가 lvalue이며 3+4가 rvalue이다. x는 왼쪽에 나온다고 해서 lvalue,
대입하는 값은 오른쪽에서 나온다고 해서 rvalue이다. 
3 + 4 = x;
x + 1 = 3;
반대가 될 수는 없다.
int x=1,y=2;
x=y;
x는 lvalue, y는 rvalue가 될까? 아니다. 여기서 x,y는 모두 lvalue이다. 즉 개념적인 것은 왼쪽, 오른쪽이지만
실제로는 약간 다른 의미를  가지고 있다.
lvalue 저장할 수 개쳋, 한줄의 코드를 넘어 지속되는 개체, 변수 등, rvalue 불가능 이름 있음
rvalue 값, 현재 식 이외에는 유지되지 않는 임시 값, 리터럴, 상수, 연산식 등, lvalue가 rvalue로 변환되어 사용 가능

배열 변수는 lvalue가 아니다.
int array1[5]={1,2,3,4,5};
int array2[5]={};
array2[0]=array1[0];
array2 = array1;
array2[0]=array1[0] array2배열의 0번째 요소에 array1배열의 0번째 요소의 값을 대입한다.
array2=array1; 이건? 일단 에러다, 식이 수정할 수 있는 lvalue여야 합니다.
배열을 설명할 때 위와 같은 그림을 사용하여 메모리를 간략하게 표현한다. 여기에서 scores라는 변수
자체는 메모리의 위치만 지정할 뿐 특별한 공간을 지정하고 있지 않는다. 포인터
따라서 scores는 lavlue가 되지 않는다. 반면 scores[0]와 같은 경우는 값을 변경할 수 있는 lvalue가 된다.

참고로 array2 = array1; 이런 표현은 왜 사용하려 했을 까 array1을 모두 array2에 넣고 ㅣㅍ을 때 그렇다.
이런건 직접 하나하나 대입해 줘야 한다.

문자열
일련의 문자들로 이루어진 집합을 문자열이라 한다. 지난 번에도 예제를 위해 조금씩 다뤘지만, 배열 이후에 다루는 이류가
바로 문자 + 배열이기 때문이다.
문자 리터럴 'ㅁ'
문자열 리터럴 " 마마ㅏ마"
문자열은 널문자를 끝에 담고 있기 때문에 문자열의 길이는 길이 + 1이다.

메모리는 연속으로 쌓여있는 공간stack으로 되어 있고, 특정 부분에 변수를 할당하여 사용하는 방식이다.
문자열 공간[10]을 준비하면 널문자 때문에 9칸의 문자만 쓸 수 있다.

int number{1};
char ame[]{"Doggy"};
float average{90.1f};
std::ostringstream oss;
oss << number
	<<"번 학생 "
	<< name
	<<"는 평균 "
	<< average
	<<"입이다.";
std::cout<<oss.str();
*/

/*
함수
수학시간에 함수라는 것은 f(x) = X + 1과 같은 개념으로 배우셨을 겁니다. 어떤 x값을 입력으로 주면 내부에서
계산을 수행한 후 결과 값을 돌려준다. 위 함수에서 x가 1이라면 1+ 1 = 2를 돌려준다. 이런 함수를 사용하는 이유
는 자주 사용되는 수식을 하나로 묶어서 재사용하기 위함이다.

함수의 특징
함수란 여러 개의 명령어로 된 집합으로 이러한 집합에 이름을 붙인 것이다. 다음과 같은 구성요소를 가진다.
반환 타입 + 이름 + 매개변수 목록 + 본체
입력을 받아 합당한 출력을 되돌려 준다는 의미에서 함수는 계산의 기본 흐름과 같다.
여기에 이름을 붙여서 여러 번 반복해서 호출할 수 있도록 만든다.
프로그래밍의 원칙은 단순성을 가장 잘 표현한 것이 이 함수라는 것으로, 반복되는 계산을 함수라는 집합으로 묶어 두면 
여러 번 타이핑 해야 하는 긴 코드를 간단하게 만들 수 있게 된다.
반환타입 : 반환타입은 형식만 지정하면 된다.
함수 이름 : 변수는 카멜 표기법을 사용한다. 함수는 변수와 구분하기 위해 카멜을 사용한다.
매개 변수 목록 : 매개변수는 함수 내에서 사용할 변수를 선언하는 것으로 매개변수가 여러 개 필요한 경우 쉼표로 구분
반환 : 함수의 실행을 멈추고 함수를 부른 곳으로 되돌아 간다. 반환타입이 void라면 값을 생략하고,
타입이 존재하면 return 뒤에 넘겨줄 값을 명시해야 한다.

입력/출력이 없는 함수
화면에 자르는 선을 출력하는 함수
void PrintDottedLine()
	std::cout<<"---------------------------\n";
위 구성요소는 다음과 같다.
반환 타입 : void 화면에 자르는 선만 출력하고 결과로 돌려줄 값은 없다.
함수 이름
매개 변수 : 연산에 수행할 값은 필요 없다.
본체 : 자르는 선만 출력
주의할 점은 위와 같이 반환값이 없다고 반환 타입을 생략할 수 없다.
void라는 형식으로 꼭 지정해 줘야 한다.

입력만 필요한 함수
숫자를 입력으로 받아서 화면에 출력하는 함수를 하나 만들어 봅시다.

void PrintNumber(int x)
	std::cout<<x<<'\n';
반환 타입 : void 화면에 출력하고 결과로 돌려줄 값을 없다.
함수 이름
매개변수 : int x
본체 : 매개변수 x를 화면에 출력
자주 헷갈리시는 것이 int x라는 매개 변수의 개념이다. 이 함수를 사용할 때는 값을 넘겨줘서 출력해야
하는데, 그 값을 받아오는 용도로 사용한다는 것만 잘 기억해 두자. 변수의 범위는 서로 다르기 때문에 
같은 변수가 아님을 명심해야 한다.

입력과 출력이 모두 필요한 함수
int Square(int x)
	return x * x;
반환 타입 : int
함수 이름 : Square
매개변수 : int x
본체 : x * x를 돌려준다.
반환값이 존재하는 함수는 반드시 return이라는 키워드를 사용하여 함수가 종료될 때 결과 값을 반환해 줘야 한다.

함수의 선언과 정의
기본적으로 C++언어는 위에서 아래로 분석하기 때문에 사용할 함수는 항상 위에 있어야 아래에서 사용이
가능합니다. 변수도 마찬가지죠? 사용하기 전에 선언을 해 둬야 했다.

전방 선언
선언과 정의를 분리하는 가장 큰 이유는 전방선언에 유용하게 사용되기 때문입니다. 미리 컴파일러에게 앞으로 사용할
함수가 존재한다는 것을 선언만으로 알려주는 것이죠.
#include <iostream>

int Square(int);

int main()
	std::cout<<Square(2)<<'\n';
int Square(int x)
	return x * x;

void f()
	g(); f에서 g를 사용
void g()
	f(); g에서 f를 사용
위와 같은 것은 순환호출이라 하며, 조금만 복잡한 프로그램을 작성하다보면 자주 발생한다. 이러한 경우는 전방선언
을 통해 해결해야 한다. 또한 전방선언의 고급활용으로 컴파일 시간 단축 등에소 사용되므로 잘 기억해 두자.

함수 선언
int Square(int);
미리 어떤 함수가 있는지 알려줘야 한다. 이러한 것을 함수선언 또는 함수 원형이라 한다.
C++의 컴파일은 위에서 부터 아래로 순서대로 진행되기 때문에 다음에 사용할 함수가 있으면 위쪽에 선언이
되어 있어야만 한다.
함수 선언에는 반환값, 이름, 매개변수 목록이 필요하다. 그리고 마지막에 꼭;을 넣어주어야 한다.

함수 정의
int Square(int x)
함수의 정의, 실제로 함수가 어떤 연산을 하는지 작성하는 곳,
함수 선언의 반환값, 이름, 매개변수 목록이 정확하게 일치해야 하며, 매개변수의 이름 역시 꼭 있어야 한다.

변수의 선언 및 초기화가 동시에 가능했던 것 처럼 함수 역시 선언과 정의를 같이 사용할 수 있다.

전처리기와 컴파일 및 링크
사실 위에서 만든 제곱을 구하는 Square(2)는 C++에서 준비되어 있는 함수를 사용할 수 있다.
C++에서는 조금 더 범용적으로 xy와 같은 거듭제곱을 사용한다. 첫번째 매개변수는 밑이고 두번째 매개변수는 지수
이다. 따라서 제곱을 구하는 함수는 위 함수로 대체가능하다.
std::cout<<pow(2,2)<<'\n';
그런데 pow(x,y)라는 함수는 어떻게 사용 가능한 것일까? 우리가 작성한 코드 어디에서 함수의 선언/정의문은
없다. 전체 프로그램을 다시 살펴보자.


#include <iostream>
이전에 잠시 언급한 #include 전처리기 지시문이다. 이건 때문에 사용이 가능하다.
비주얼 스튜디어 좌측 부분의 솔루션 탐색기를 살펴보면 다음과 같이 외부 종속성이라는 항목이 있다.

cout, pow, endl 같은 기능들이 전부 컴파일러 오류 상태가 되고, 외부 종속성에 아무런 것도 들어 있지 않을 것이다.
#include 라는 키워드로 인해 <>로 둘러싼 iostream 이라는 것이 우리 소스에 포함되어지는 것

컴파일과 링크
main() 함수
눈치 채셨습니까? 우리가 사용하던 프로그램에는 모두 int main() 이 붙어 있습니다. 컴퓨터는 프로그램이
실행될 때 자동적으로 main()이라는 함수를 호출해서 우리 프로그램을 실행하는 것입니다. main 함수는 다음과 같은 종류가 있다.
int main(int argc, char* argv[], char* envp[])
이런 메인 함수를 프로그램의 진입점이라고 부른다. 그런데 분명히 반환값이 있는 함수인데 반환한 적이 없다.
메인 함수는 return을 명시하지 않아도 자동적으로 0을 반환하며 프로그램을 종료한다.

Local, Global, Extern, Static 변수
함수를 사용할 때 가장 헷갈리 쉬운 것이 변수입니다. 변수의 범위에 대해 조금 더 자세히 알아보고 넘어가겠다.

int main()
	int myInteger{5};
myInteger는 main함수가 끝나면 소멸된다. main() 블록 내부에 정의되었기 때문에 이 블록을 넘어가면 소멸된다.

int main()
	int myInteger{5};
	for(int i=0;i<5;i++)
		int myInteger2{0};
		myInteger = myInteger2 = i;
	std::cout<<myInteger<<" , "<<myInteger2<<'\n';
실행 결과는 어떻게 될까요?
우선 에러입니다. myInteger2변수는 for{}블록 안에서 정의되었으므로 블록을 넘어가면 소멸된다.
따라서 11라인은 에러가 발생한다. 하지만 myInteger 변수는 for{} 블록 받에서 정의되었던 변수이므로
for 내부에서 사용해도 아무런 문제가 없다.
이렇게 {}블록 안에서 정의된 변수를 지역 변수라 한다.

반대로 소스파일 어디에서도 사용할 수 있는 변수를 전역 변수라 한다.
int myGlobalInteger = 5;

int main()
	int myInteger{};
	myInteger = myGlobalInteger;

	std::cout<<myInteger<<'\n';
위와 같이 main{} 블록 가장 바깥에 선언한 변수는 main함수 내부에서도 사용할 수 있습니다.
하지만 전역 변수를 프로그램을 분석하기 매우 어렵게 만들기 때문에, 전역변수는 가급적 사용하지 않도록 한다.
조금더 강의를 진행해서 언어를 익히면 전여변수 없이도 얼마든지 개발할 수있다.

위 예제는 main 함수에서 사용했던 것으로, 다른 함수에서도 역시 변수를 정의할 수 있다.
void func()
	int x;
void func2()
	x =1; 에러 발생

void func1()
	int x;
void func2()
	int x; 서로 다른 x

정적 변수
매우 특이한 형태를 가지는 종류가 하나 더 있습니다. 정적 변수라는 종류는 static 키워드를 붙여서 변수를 만든다.
static 타입 변수명;
정적 변수는 오직 한 번만 생성되어 프로그램이 종료될 때 까지 살아남는다는 특성을 가지고 있다.

은행의 대기번호 발권기를 함수로 구현한다고 가정하다
int GetOrder()
	int number{};
	return number++;

int main()
	for(int i=0;i<10;i++)
		std::cout<<GetOrder()<<'\n';
문록, 이렇게 구현하면 지역 변수의 범위 때문에 GetOrder::number는 매번 초기화되겠조?

하지만 오직 한 번만 생성되어 프록그램 종료될 때까지 살아남는다는 정적 변수를 사용한다면?
int GetOrder()
	static int number{};
	return number++;
위에서 보시는 것처럼 i = 0일 때 즉 최초 한번만 정적 변수 number를 선언 및 초기화를 하며 그 이후에는
마치 전역 변수인 것처럼 값이 살아 있게 된다. 하지만 변수의 범위로 보면 다른 곳에서는 사용할 수 없기
떄문에 로컬 변수와 같은 범위이다.
때문에 main에서 호출하면 에러가 발생한다.
즉, 정적 변수는 두 가지 개념을 조합해야 특성을 설명할 수 있다.
변수 범위 local
변수의 주기 static
전역 변수와 마찬가지로 한 번 생성되면 프로그램이 종료도리 때까지 남아있어서 사용을 권장하지는 안는다.
그러나, 게임 시작과 동시에 오직 하나만 생성되어 끝날때까지 남아있을 필요가 있는 경우 자주 사용된다.

매개변수와 인자
int Square(int x);

int main()
	int x = 2;
	int result = Square(x);

	std::cout<<result<<'\n';
int Square(int x)
	int result = x * x;
	return result;
int x = 2;
int Square(int x)
5번 줄의 x는 main() 블록이며 11번 줄의 함수의 정의에 사용된 매개 변수이다.
이름으로 x로 서로 같지만 다른 변수이다.
즉, 매개 변수는 지역 변수라는 의미이다. 매개 변수는 함수 블록이 끝나면 사라진다.
int result = Square(x);
int result = x * x;
6번 줄의 result는 main()블로의 지역 변수이며 13번줄의 result는 Square(){}블록의 지역변수입니다.
역시 서로 다른 변수입니다.

int Square(int x) 함수의 정의/선언에 사용하는 변수를 매개변수라 부른다.
int result = Square(x)
함수를 호출할 떄 넘겨주는 변수를 인자라 부란다.
인자는 상수, 산술 표현식, 논리 표현식, 결과값이 있는 함수를 모두 사용할 수 있다.
Square(2)
Square(3+x)
Square(Square(x))
함수를 호출할 때 인자의 값이 매개변수로 복사되어서 넘어간다.
이러한 것을 값에 의한 호출 Call By Value라고 부르며 함수에서 중요한 개념이니 기억해 두자.

함수에 배열 넘겨주기
5개의 정수를 가진 배열을 매개변수로 넘겨줘서 합을 구하는 함수를 작성해 보겠다.
int Sum(int input[5])
	int sum{};

	for(int i=0;i<5;i++)
		sum+=input[i];
	return sum;
int main()
	int numbers[] = {1,2,3,4,5};
	std::cout<<Sum(numbers);
위와 같이 매개변수에 배열 형태 그대로 선언해서 사용할 수 있다.
하지만, 이렇게 사용할 경우에 주의해야 한다.
위에서 인자가 매개변수로 복사되어 진다고 설명했다. 즉 인자와 매개변수는 서로 다른 값이다.

int sum(int input[5])
	int sum{};
	for(int i=0;i<5;i++)
		sum += input[i];
	input[0] = 0;
	input[1] = 0;

	return sum;
int main()
	int numbers[] = {1,2,3,4,5};
	std::cout<<Sum(numers);
	std::cout<<'\n';
	std::cout<<numbers[0]<<", "<<numbers[1];
영향이 없어야 하는데, 위 코드를 실행해 보면 numbers배열의 값이 바뀐 것을 확인할 수 있다.
즉, 일반 타입과 배열은 매개변수로 처리될 때 그 방식이 다르다는 것을 알 수 있다.
일반 타입은 복사 되어 다른 값이 되지만, 배열은 그 배열 자체가 그대로 전된되는 것이다.

아마도 일반 타입이 여러개 있으니 전부 복사하면 느려지기 때문에 이렇게 했을 거라고 추축해 볼수 있겠죠

매개변수 일치

void Who(int value);
void Who(float value);
void Who(float value, float value2);

int main()
	Who(10.0f);
3개의 동일한 이름의 함수가 있다. main에서 호출한 함수는 어떤 함수일까
서로 같은 이름으로 인해 처리하기가 어려운 모호성이라고 하며 C++함수는 이런 것을 방지하기 위해 매개변수 일치
라는 조건을 가지고 있다.
즉, 호출할 때 넘겨주는 인자가 파라미터와 같은지 검사하는 거다.

Who(10.0f) 이 함수는 소수 10.0f를 인자로 넘겼으므로 3가지 함수 중 float을 매개 변수로 가지는 Who(float value)가
호출된다..

함수의 오버로딩
다음과 같이 변수를 입력받아 해당 변수를 출력하는 함수를 생각해보자. 다양한 타입이 있으므로 다음과 같이 만들 수 있다.
int PrintInt(int i);
int PrintFloat(float f);
int PrintDoub(double d);
하지만 지저분하고 관리하기도 번거롭다.

int Print(int i);
int Print(float f);
int Print(double d);
이렇게 사용하면 관리도 편하고 보기도 훨씬 좋다. 이렇게 위에서 설명한 매개변수 일치와 같은 개념을 이요하여 함수 다형성
을 이끌어 낼 수 있다.
말 그대로 형태가 다양하다는 뜻이다. 이를 함수 오버로딩이라 한다.
함수 오버로딩에 사용되는 함수 선언 요소는 다음과 같다.
반환값 X
매개변수 갯수 O
매개변수 타입 O
포로는 설명이 부족하니 예를 들어 보자
int Print(int i);
int Print(double d);
int Print(double d, int i);
당연히, 오버로딩은 같은 함수 이름을 가져야 한다. 매개변수 타입이나, 개수가 서로 다르더라도 반환값과 이름이 같다면
이러한 것을 함수 오버로딩이라 부른다.

int Print(int i);
void Print(double d);
위 두 함수는 오버로딩이 아니다. 반환값이 다르면 서로 다른 함수로 취급하기 때문이다.

함수 시그니쳐
함수의 이름, 매개변수의 타입, 개수, 순서를 함수의 특성을 나타내는 고유값 시그니쳐라 부른다.
오버로딩에서 함수를 구분하기 위해 내부에서 사용하는 정보가 이 시그니쳐이다. 반환값은 시그니쳐에 포함되지 
않는다는 점을 기억해라.
int Print(int i);
void Print(int i);
이름, 매개변수는 같지만 반환값만 다르다. 이 경우 시그니쳐가 같은 삼수가 두개 존재하기 때문에 컴파일 에러가
발생한다.

함수의 반환 값
함수의 결과를 함수를 호출한 곳에 되돌려 준다. return키워드를 사용하며 뒤에는 표현식이 올 수 있다.
return;
return ++index;
return (a * b);
함수는 순서대로 진행되다가 return 을 만나면 종료되고 ,호출한 환경으로 제어권이 넘어가게 된다.
함수의 흐름에 따라 return이 하나 이상 있을 수 있으며, 가장 마지막에 위치하지 않을 수도 있다.

char ConvertToUpperCase(char input);

int main()
	char buffer[50] = "Hello World";

	for(int i = 0; i < 50; i++)
		std::cout<<ConvertToUpperCase(buffer[i]);
	char ConvertToUpperCase(char input)
		if(input >= 'a' && input <= 'z')
			return input - 'a' + 'A';
			return input;

함수의 작동 원리
컴퓨터에서 일어나는 일을 알아두면 프로그래밍에도 도움이 되긴 하지만, 나중에 디버깅을 할 떄 매우 도움이
되기 때문에 함수가 어떻게 컴퓨터에서 도앚ㄱ하는 지를 잠시 살펴 보겠다.

void f(int x)
	int y = 1;
	g(x);
void g(int x)
	int z = 1;
int main()
	int x = 1;
	f(x);
main -> f -> g / 변수와 인자들을 위해서는 추가적인 정보가 필요하다.
프로그램이 시작되면 main함수가 
시작되고 로컬 변수 x를 준비한다. 그리고 함수 f(x)를 호출하면 다음과 같이 흐름
이 분기된다.
기존의 main정보 위에 새로운 함수 정보를 붙여둔다. 함수에 필요한 인자x와 로컬변수 y를 준비한다.
그림에서 본 것 처럼 동일한 타입과 이름의 x는 다른 공간에 존재하는 변수라는 것을 알 수 있다.
다시 g를 호출한다.
기존 정보 위에 새롭게 g함수에 대한 인자와 로컬 변수를 준비한다. g함수를 모두 처리하고 나면 반환하게되고
그럼 함수 f로 돌아간다. 간단히 가장 마지막에 추가한 g를 꺼내면 f로 돌아갈 수 있다.
f역시 처리가 완료 되고 반환하면 다음고 ㅏ같이 된다.
위와 같은 것을 함수 활동 기록이라고 부르는데, 특이한 구조를 가지고 있어서 새로 호출되는 것을 쌓고 반환하며 마지막에
저장된 것을 꺼내면 된다.
마지막에 들어온 것을 먼저 꺼낸다. 라는 자료구조를 스택이라고 하며 함수의 진행과정을 호출 스택이라 한다.
디버깅을 할 때는 호출 스택을 자주 사용하게 될 것이므로 개념을 알아두자.

스택과 큐
그럴듯한 프로그램
함수는 프로그래머에게 매우 중요한 수단이다. 코드를 보기 좋고 관리하게 편하게 만들어 준다.
주어진 start, end까지의 아스키 코드와 해당 문자를 출력하는 프로그램
우선 바로 코딩에 들어가지 말고 내용을 정리해 보자.

int main()
	// 시작 문자(start) 끝문자(end)를 입력 받는다.
	// 타이틀 출력
	// 아스키 테이블에서 start ~ end까지 출력

char ReadInput();
void PrintHeader();
void PrintTable(char start, char end);

int main()
	std::cout<<"아스키 문자 시작, 끝을 입력하세요!";
	// 시작문자 끝문자를 입력 받는다.
	char start{ ReadInput{} }, end{ ReadInput() };
	// 타이틀 출력
	PrintHeader();
	// 아스키 테이블에서 start ~ end까지 출력
	PrintTable(start, end);
char GetAsciiCharacter(int code)
	// 정수를 문자로 변환
void PrintTable(char start, char end)
	// start ~ end 반복
		// 정수 : 문자 형태로 출력
		GetAsciiCharacter();
문론 설명을 위해 무리하게 함수로 구분해서 만들긴 했지만 실제 업무에서의 흐름을 연습하기 위한 것으로 이해
하면 된다. 이렇게 잘게 자를필요는 없다.

char ReadInput()
	char ch;
	std::cin>>ch;
	return ch;
void PrintHeader()
	std::cout<<std::endl;
	std::cout<<"----ASCII TABLE----";
	std::cout<<std::endl;
char GetAsciiCharacter(int code)
	return (char)(code);
void PrintTable(char start, char end)
	for(int ch = start; ch <= end; ch++)
		std::cout<<ch<<
			'\t'<<
			GetAsciiCharacter(ch) <<
			std::endl;
지금까지의 강의를 잘 따라왔다면 분석에 큰 어려움 없다.

대규모 프로젝트라면 위 코드에서 함수의 선언과 정의는 다른 파일에 존재하게될 것이고 main은 아주 간략해질 것이다.
32 : for(int i=start; i<=end; i++)
여기에서는 암시적인 변환을 사용했다. char(1byte)는 int(4byte)로 변환에도 아무언 문제가 없는 변환이다.
실제 코드에서는 명시적으로 형을 변환시켜 주는 것이 좋다.

매개변수의 기본값
함수 선언의 매개변수를 지정할 때 기본 매개변수로 만들어서 인자를 생략할 수도 있다.
int MyFunction(int x = 50); 선언에서 매개변수 = 값와 같이 기본 값을 지정할 수 있다.
MyFunction(); 호출할 때 인자를 생략할 수 있다.
int MyFunction(int x) 인자를 생략한 후 함수 본체의 매개 변수는 자동적으로 기본 값이 배정된다.
함수 선언에서 매개변수의 타입만 지정할 수도 있으므로 위 내용은 다음과 같이도 표현 가능하다.

당연히 한 개 이상의 매개변수도 사용 가능하다.
void Point(int x = 1, int y = 2, int z = 3);
Point(4,5,6); Point(4,5,6)호출
Point(4,5); Point(4,5,3)호출
Point(4); Point(4,2,3)호출
Point(); Point(1,2,3)호출
주의할 점은 기본 매개변수는 매개변수 목록 마지막에 위치해야만 한다.
int MyFunction(int x= 10, int y);
이렇게 매개 변수의 기본값을 지정했다고 가정하자, 그러면 myFunction(1)을 호출했을 때 컴파일러는 이것이
x를 생략하고 y에 대한 인자를 준 것인지, 아니면 프로그래머 실수로 한 개만 입력한 것인지 구분할 방법이 없다.
그래서 이런 모호성을 확실히 제거하기 위해 기본 매개변수는 고정 매개변수 뒤에 와야 한다라는 조건이 만들어
진것이다.

가변인자
임의의 변수, 함수의 매개변수를 여러개 넘겨 줄 수 있다는 의미가 가변 인자이고, 그 여러개의 변수를 줄여서
표현하는 것이 sllipses라고 보면 된다. 생략을 의미하는 줄임표(...)를 Ellipses라고 부른다.

void function(int a)
	std::cout<<a<<'\n';
void function(int a, int b)
	std::cout<<a<<' '<<b<<std::endl;
int main()
	function(1);
	function(2,3);
동일한 이름의 서로 다른 파라미터를 가진 함수입니다. 이러한 것을 함수 오버로딩으로 위와 같이 표현할 수 있지만
조금 더 깔끔하게 처리하기 위해서는 가변 파라미터를 받게하면 더 편합니다.
void functino(int count, ...)
	va_list params;
	va_start(params, count);
	for(int i=0;i<count;i++)
		std::cout<<va_arg(params, int);
	std::cout<<std::endl;
int main()
	funciton(1,1);
	function(2,2,3);
이렇게 함수를 말줄임표를 이용해 가변 매개변수로 만들 수 있다. 단, 가변 매개변수를 넘겨주기 위해서는
최소 1개의 고정 매개변수가 필요하다. 여기서는 매개변수의 개수를 지정하는 count로 사용했다. 가변 매개변수를 사용
하려면 stdarg.h가 필요하고 va_list, va_start, va_arg등과 같은 함수를 사용하면 된다.
*/

/*
재귀 함수
함수의 내부에서 자기 자신을 다시 호출하는 함수를 재귀 함수라고 한다.이전 예제에서 스택 오버플로를 일으킨 것 역시 이 재귀함수다.
따라서 매우 위험하지만 그 만큼 유용한 경우가 많기 때문에 알아두고 넘어가자.
실제로 테트리스, 3-math류 게임으 ㅣ판정이나 사천성 류 게임에서 매우 편리하게 쓸 수 있으며, 길찾기 로직
에서도 매우 유용하다.

Divide & conquer
재귀 함수를 사용하는 목적은 분할정복이다.
큰 문제를 잘라서 작은 문제로 만든 후 간단해진 문제를 재귀적으로 해결하기 위함이다.
분할 정복을 해결하는 방법 중 가장 대표적인 것이 재귀호출인데, 이를 적용하기 위해서는 다음과 같은 조건을
만족해야 한다.

동일한 문제의 작은 집합을 가진 문제

9에서 0까지 출력
9 8 7 6 5 4 3 2 1 0
9까지의 큰 문제를 9까지의 작은 문제로 자를 수 있다. 즉 9까지의 문제를 해결하기 위해선 8까지의
문제를 해결하고 오면 된다.
n 출력
(n-1)로 재귀
0까지 출력해야 하므로 가장 마지막 단위는 (0), 그럼 더이상 자를 수 없는 단위 -1진행이 불가능한 상태
문제를 분할할 수 없으니 종료해야 함

void ForLoop(int N)
	if(자를 수 없는 문제?)
		return;
	N 출력;
	ForLoop(N - 1);

void ForLoop(int N)
	if(N < 0)
		std::cout<<'\n';
		return;
	std::cout<<N<<", ";
	ForLoop(N - 1);

ForLoop함수에서 ForLoop함수를 호출한다. 이제 재귀호출이다. 이 함수의 결과를 예측해 보자.
일단 출력하고 재귀 호출을 한다.

	ForLoop(N-1);
	std::cout<<N<<", ";
위와 같은 경우 재귀호출을 한 뒤에 출력을 한다.
호출스택은 Stack이라는 구조를 사용하고 있기 때문에 값을 쌓을 떄 출력하는 것

재귀호출의 정의
재귀호출 함수는 크게 다음과 같은 형태로 되어 있다.
void Function( x )
	if( 종료 조건 )
		return;
	Function( 재귀 연산 )
기본적으로 함수 내부에서 함수를 호출하는 형태라서 반드시 함수를 빠져나가는 종료 상태를 만들어 두어야 한다.
그렇지 않으면 무한 호출에 빠진다.

이 개념을 분할 정복에 맞춰서 설명하자면 다음과 같다.
Base Case
	더이상 자를 수 없는 가장 기본 상태로 간단히 풀 수 있는 최소 단위
	이게 주로 종료 조선이 된다.
Recursive Cse
	재귀적으로 문제를 해결하는 상태로 주로 자신의 함수를 재귀연산을 통해 호출하게 된다. 주의할 점은 재귀 연산
	은 문제의 볌위를 좁혀서 Base Case로 만들어야 한다는 점이다. 그렇지 않으면 끝나지 않는다.


*/