#pragma once

/*
컴파일과 링크 고급
헤더파일과 소스파일
C++언어는 선언과 정의로 구분되어 있다.
보통 프로그램을 작성하다보면 상당히 많은 양의 코드를 입력하게 되며, 효율적으로 작성하기 위해 반복되는
작업들을 따로 묶어서 선언하는 경우가 많다. 또한 다른 사람이 만들어둔 편리한 기능들을 가져다 사용할 경우도
있다. 그래서, 선언과 정의를 다음과 같이 개별 파일로 묶어둔다.

헤더파일 : 함수나 변수의 선언을 모아둔 파일, 어떤 기능이 있는지, 어떤 규격인지 알려주는 용도
소스파일 : 함수나 변수의 정의를 모아둔 파일, 실제 기능을 구현하는 곳
라이브러리 파일 : 소스파일을 코드가 아닌 컴파일된 기계어로 제공하는 파일, 주로 자신이 만든 기능을 배포,
프레임 워크 처럼 한 번 만들고 자주 수정하지 않는 기능을 포함시킬 떄 사용
C++의 전신인 C언어에서는 h와 c를 사용했다. C++이 되면서 이를 구분하기 위해 많은 확장자들이 생겼지만,
이번 강의에서는 비주얼 스튜디어가 기본으로 생성하는 h와 cpp를 사용하겠다. xcode등 다른 ide를 사용하면 기본
값이 다를 수 있다.
#include 지시사
우리가 만든 다음 코드의 컴파일 및 링크를 조금더 자세히 살펴보겠다.
MyHeader.h
#pragma once

int Square(int x);
Square함수에 대한 선언이다. 헤더는 크게 사용자가 만든 헤더와 시스템 헤더로 구분된다.
시스템 헤덩 : C++언어 및 standard library에서 기본적으로 제공하는 기능들이 있다.
이러한 기능들을 시스템 헤더라 부른다. ide정확하게는 컴파일어에 기본적으로 내장되어 있다.
사용자 헤더 : 프로그래머가 직접 만든 헤터

첫번째 전처리기 지시자인 #pragma once는 단 한번만 선언하라는 의미이다. #include를 사용하여 MyHeader.h를
여러 소스파일에서 포함시킬 수 있다.이럴 켱우 중복 선언 에러가 발생할 수 있다. 따라서 중복선언을 피하기
위해 #pragma once를 명시해 줘야 한다.

MySource.cpp
#include "MyHeader.h"

int Square(int x)
	return x * x;
Square함수에 대한 저으이이다. 기존 코드들과 차이점이 있다면 #include ""이다.

#include < ... > : 시스템 헤더 파일을 포함한다.
	정확하게는 시스템에 정의되어 있는 경로에서 찾는 다는 의미이다.
#include " ... " : 사용자 헤더 파일을 포함한다.
	정확하게는 다음과같이 여러번 탐색을 한다.
	1. 현재 소스가 있는 디렉토리
	2. 현재 헤더가 있는 디렉토리
	3. 시스템에 정의되어 있는 디렉토리
약간 의미는 다르지만, 통일성을 위해 시스템 헤더는 <>, 사용자 헤더는 ""사용하면 된다.

Main.cpp
#include <iostream>
#include "MyHeader.h"

using namespace std;

int main()
	cout<<Square(2)<<'\n';
	cout<<pow(2,2)<<'\n';
시스템 헤더는 #include <iostream> / 사용자 헤더는 #include "MyHeader.h"로 구분하여 포함시킨다.

컴파일과 링크
위 예제의 컴파일과 링크 과정을 조금 살펴보자. 우선 헤더와 소스파일의 관계를 살펴보자
기본적으로 헤더 파일은 컴파일에 사용되지 않는다. 대신 소스파일의 전처리기 지시다 .#include를 통해
소스 파일에 포함된다. 전처리기라고 부르는 이유가 바로 컴파일 이전 단계에 수해되어 소스파일을 수정하기 떄문

즉, MySource.cpp를 컴파일 할때는 내부적으로 다음과 같이 된다.
int Square(int x);

int Square(int x)
	return x * x;
#include 지시자가 MyHeader.h.를 포함시키기 때문에 헤더 파일의 내용에 해당 라인에 삽입되는 것

Main역시 마찬가지

int Sqare(int x);

usinng namespace std;

int main()
	cout<<Square(2),,'n\'

iostream의 내요ㅛㅇㅇ느 엄청나게 길고, 여러개의 다른 헤더파일을 추가로 포함하고 있기 때문에
개념으로만 이해하기바란다. 주의할께 이단계에서는 함수의 선언만 포함되며, 정의는 MYSouce에 속해있다.
수동으로 컴파일을 진행해 보자
1. 빌드 > 솔루셔 정리를 눌러서 현재 프로젝트의 중간 파일들을 모두 청소한다.
2. MySource.cpp를 열고 빌드 > 컴파일을 눌러서 컴파일을 진행한다.
3. 마찬가지로 main을 열고 빌드 컴파일을 누른다.
프로젝트 폴더를 Debug라는 폴더가 있고 해당 폴더를 열어보면 컴파일 결과물을 볼 수 있다.
컴파일러가 컴파일을 성공하면 각각 MYSource.obj, main.obj라는 목적어 파일을 만들어 둔다. 목적어 파일은 헤더 파일의
내용을 포함 시킨 후 다음 단계인 링크에 필요한 정보들을 미리 모아두는 것이다.

다음 단계는 링크이다. 위에서 만들어진 목적어 파일을 연동하여 실행파일을 만든 것이 링크이다.

정적 라이브러리와 동적 라이브러리
보통 프로그램을 제작하다 보면 외부 라이브러리라는 것을 많이 사용하게 된다. 다른 개발자가 미리 만들어 둔
유용한 기능을 가져다 사용하는 방식이다. 다른 개발자가 소스를 공개할 수도 있지만, 지적 재산권 문제나
개발 속도 측면에서는 이렇게 소스를 복사하여 사용하는 것은 좋은 방식이 아니다. 따라서 컴파일이 모두 끝난 obj파일
들을 한 번에 묶어서 링크에 사용할 수 있도록 해주는 것이 라이브러리다.

정적 라이브러리
정적 라이브러리는 정적, 즉 변경할 수 없다는 의미다. 한 번 만들어진 라이프버리는 lib파일로 사용하는데
이렇게 한 번 만들어진 내부 기능은 변경할 수 있는 방법이 없다. 만약 버그 수정이나 기능 추가등으로 인해 내용을
변경해야 한다면 lib파일을 재배포 하는 방법밖에 없다.
정적 라이브러리는 보통 헤더파일과 라이브러리파일을 제공하며, 이를 각각 컴파일/링크 단계에 추가해 준다.
헤더파일은 당연히 우리의 소스 코드에 직접 include를 통해 지정해 준다.
라이브러리는 외부 종속성에 추가해 주는데 비주얼 스튜디오에서는 다음과 같이 지정해 준다.

프로젝트 > 속성 을 누르면 나타나는 설정화면으로 링커 > 입력 > 추가 종속성에 추가할 라이브러리 파일을 
넣어 주면 된다.

동적 라이브러리
정적 라이브러리는 내용이 변경되어 라이브러리 파일을 재배포해도 큰 문제가 있다. 사용자가 해당 라이브러리를 갱신
하기 위해서는 자신의 프로젝트를 다시 빌드해 줘야 합니다. 가령 다음과 같은 예를 들어 보자
1. 게임의 피명적인 버그 발견
2. 디버그 해보니 외부 라이브러리의 버그로 새로운 버전으로 업데이트 필요
3. 새로운 라이브러리를 다운 받고 프로젝트 다시 빌드
4. 사용자에게 실행파일 재배포

위와 같은 흐름이 된다. 개발 프로세스에서 3번 이슈는 치명적이다. 상용 프로젝트는 빌드 한번 하는데 몇시간
씩 걸린다. 그리고 QA팀 입장에서는 프로젝트가 빌드되면 전체 검수를 다시 해야 한다.
최근에는 인터넷이 빨라져서 부담이 없긴 하지만 사용자에게 재배포 하는 이슈도 크다.

위와 같은 문제로 인해 잔머리를 굴려 만든 것이 실행시간에 링크가 가능한 동적 라이브러리이다. dll
동적 라이브러리는 링크 과정에서 간단한 정보만 남겨놓고, 실행 시간에 그 정보를 이용해 기능을 링크 하는 방식을
사용한다. 따라서 라이브러리의 기능이 변경되어도 다시 빌드할 필요 없이 간단히 라이브러리만 배포하면 된다.

이러한 동적 라이브러리는 헤더파일과 라이브러리파일 그리고 동적 라이브러리 파일을 제공한다.
동적 라이브러리의 lib는 정적 라이브러리으 ㅣ그것과는 달리 내부에 함수 본체와 같은 상세 정보는 없고 오직
정보만을 기록하고 있다. 함수 본체는 dll에 들어있다.

스택과 큐
컴퓨터는 기본적으로 입력을 받아 계산하고 출ㄹ력하는 것이다. 따라서 자료를 입력/출력으로 전달할 때나 계산에
사용할 때의 정보가 매우 중요하다. 기본 형인 정수만 사용해서는 표현 범위가 제한되기 때문에 다양한 방식을 사용하는데 
이러한 것을 자료구조하 부른다.
이러한 자료 구조 중 가장 기본적이면서 하드웨어ㅡ, 소프트웨어 구조 모두에서 사용되는 것이 스택과 큐이다.

스택
사전적으로 쌓는다는 의미다.
책을 쌓게 되면, 순서대로 위에서 부터 하나씩 꺼내야 한다. 가장 바다에 놓인 책을 뽑는 것도 않된다.
이러한 특성을 후입선출 또는 LIFO라고 한다.
스택은 가장 최근 작업이 중요한 경우에 주로 사용된다. 대표적으로 함수 호출 관리에 스택이 사용된다.

큐
사전적으로 줄을 서다라는 의미다.
가장 먼저 온 손님은 그만큼 오래 기다렸기 때문에 가장 먼저 처리해 줘야 한다.
큐는 여러 개 실행되는 작업을 순차적으로 처리할 때 사용된다. 대표적으로 윈도의 메시지 처리 및 프로세스 관리네
사용된다.
*/