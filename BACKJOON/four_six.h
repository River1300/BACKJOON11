#pragma once

/*
컴파일과 링크 고급
헤더파일과 소스파일
C++언어는 선언과 정의로 구분되어 있다.
보통 프로그램을 작성하다보면 상당히 많은 양의 코드를 입력하게 되며, 효율적으로 작성하기 위해 반복되는
작업들을 따로 묶어서 선언하는 경우가 많다. 또한 다른 사람이 만들어둔 편리한 기능들을 가져다 사용할 경우도
있다. 그래서, 선언과 정의를 다음과 같이 개별 파일로 묶어둔다.

헤더파일 : 함수나 변수의 선언을 모아둔 파일, 어떤 기능이 있는지, 어떤 규격인지 알려주는 용도
소스파일 : 함수나 변수의 정의를 모아둔 파일, 실제 기능을 구현하는 곳
라이브러리 파일 : 소스파일을 코드가 아닌 컴파일된 기계어로 제공하는 파일, 주로 자신이 만든 기능을 배포,
프레임 워크 처럼 한 번 만들고 자주 수정하지 않는 기능을 포함시킬 떄 사용
C++의 전신인 C언어에서는 h와 c를 사용했다. C++이 되면서 이를 구분하기 위해 많은 확장자들이 생겼지만,
이번 강의에서는 비주얼 스튜디어가 기본으로 생성하는 h와 cpp를 사용하겠다. xcode등 다른 ide를 사용하면 기본
값이 다를 수 있다.
#include 지시사
우리가 만든 다음 코드의 컴파일 및 링크를 조금더 자세히 살펴보겠다.
MyHeader.h
#pragma once

int Square(int x);
Square함수에 대한 선언이다. 헤더는 크게 사용자가 만든 헤더와 시스템 헤더로 구분된다.
시스템 헤덩 : C++언어 및 standard library에서 기본적으로 제공하는 기능들이 있다.
이러한 기능들을 시스템 헤더라 부른다. ide정확하게는 컴파일어에 기본적으로 내장되어 있다.
사용자 헤더 : 프로그래머가 직접 만든 헤터

첫번째 전처리기 지시자인 #pragma once는 단 한번만 선언하라는 의미이다. #include를 사용하여 MyHeader.h를
여러 소스파일에서 포함시킬 수 있다.이럴 켱우 중복 선언 에러가 발생할 수 있다. 따라서 중복선언을 피하기
위해 #pragma once를 명시해 줘야 한다.

MySource.cpp
#include "MyHeader.h"

int Square(int x)
	return x * x;
Square함수에 대한 저으이이다. 기존 코드들과 차이점이 있다면 #include ""이다.

#include < ... > : 시스템 헤더 파일을 포함한다.
	정확하게는 시스템에 정의되어 있는 경로에서 찾는 다는 의미이다.
#include " ... " : 사용자 헤더 파일을 포함한다.
	정확하게는 다음과같이 여러번 탐색을 한다.
	1. 현재 소스가 있는 디렉토리
	2. 현재 헤더가 있는 디렉토리
	3. 시스템에 정의되어 있는 디렉토리
약간 의미는 다르지만, 통일성을 위해 시스템 헤더는 <>, 사용자 헤더는 ""사용하면 된다.

Main.cpp
#include <iostream>
#include "MyHeader.h"

using namespace std;

int main()
	cout<<Square(2)<<'\n';
	cout<<pow(2,2)<<'\n';
시스템 헤더는 #include <iostream> / 사용자 헤더는 #include "MyHeader.h"로 구분하여 포함시킨다.

컴파일과 링크
위 예제의 컴파일과 링크 과정을 조금 살펴보자. 우선 헤더와 소스파일의 관계를 살펴보자
기본적으로 헤더 파일은 컴파일에 사용되지 않는다. 대신 소스파일의 전처리기 지시다 .#include를 통해
소스 파일에 포함된다. 전처리기라고 부르는 이유가 바로 컴파일 이전 단계에 수해되어 소스파일을 수정하기 떄문

즉, MySource.cpp를 컴파일 할때는 내부적으로 다음과 같이 된다.
int Square(int x);

int Square(int x)
	return x * x;
#include 지시자가 MyHeader.h.를 포함시키기 때문에 헤더 파일의 내용에 해당 라인에 삽입되는 것

Main역시 마찬가지

int Sqare(int x);

usinng namespace std;

int main()
	cout<<Square(2),,'n\'

iostream의 내요ㅛㅇㅇ느 엄청나게 길고, 여러개의 다른 헤더파일을 추가로 포함하고 있기 때문에
개념으로만 이해하기바란다. 주의할께 이단계에서는 함수의 선언만 포함되며, 정의는 MYSouce에 속해있다.
수동으로 컴파일을 진행해 보자
1. 빌드 > 솔루셔 정리를 눌러서 현재 프로젝트의 중간 파일들을 모두 청소한다.
2. MySource.cpp를 열고 빌드 > 컴파일을 눌러서 컴파일을 진행한다.
3. 마찬가지로 main을 열고 빌드 컴파일을 누른다.
프로젝트 폴더를 Debug라는 폴더가 있고 해당 폴더를 열어보면 컴파일 결과물을 볼 수 있다.
컴파일러가 컴파일을 성공하면 각각 MYSource.obj, main.obj라는 목적어 파일을 만들어 둔다. 목적어 파일은 헤더 파일의
내용을 포함 시킨 후 다음 단계인 링크에 필요한 정보들을 미리 모아두는 것이다.

다음 단계는 링크이다. 위에서 만들어진 목적어 파일을 연동하여 실행파일을 만든 것이 링크이다.

정적 라이브러리와 동적 라이브러리
보통 프로그램을 제작하다 보면 외부 라이브러리라는 것을 많이 사용하게 된다. 다른 개발자가 미리 만들어 둔
유용한 기능을 가져다 사용하는 방식이다. 다른 개발자가 소스를 공개할 수도 있지만, 지적 재산권 문제나
개발 속도 측면에서는 이렇게 소스를 복사하여 사용하는 것은 좋은 방식이 아니다. 따라서 컴파일이 모두 끝난 obj파일
들을 한 번에 묶어서 링크에 사용할 수 있도록 해주는 것이 라이브러리다.

정적 라이브러리
정적 라이브러리는 정적, 즉 변경할 수 없다는 의미다. 한 번 만들어진 라이프버리는 lib파일로 사용하는데
이렇게 한 번 만들어진 내부 기능은 변경할 수 있는 방법이 없다. 만약 버그 수정이나 기능 추가등으로 인해 내용을
변경해야 한다면 lib파일을 재배포 하는 방법밖에 없다.
정적 라이브러리는 보통 헤더파일과 라이브러리파일을 제공하며, 이를 각각 컴파일/링크 단계에 추가해 준다.
헤더파일은 당연히 우리의 소스 코드에 직접 include를 통해 지정해 준다.
라이브러리는 외부 종속성에 추가해 주는데 비주얼 스튜디오에서는 다음과 같이 지정해 준다.

프로젝트 > 속성 을 누르면 나타나는 설정화면으로 링커 > 입력 > 추가 종속성에 추가할 라이브러리 파일을 
넣어 주면 된다.

동적 라이브러리
정적 라이브러리는 내용이 변경되어 라이브러리 파일을 재배포해도 큰 문제가 있다. 사용자가 해당 라이브러리를 갱신
하기 위해서는 자신의 프로젝트를 다시 빌드해 줘야 합니다. 가령 다음과 같은 예를 들어 보자
1. 게임의 피명적인 버그 발견
2. 디버그 해보니 외부 라이브러리의 버그로 새로운 버전으로 업데이트 필요
3. 새로운 라이브러리를 다운 받고 프로젝트 다시 빌드
4. 사용자에게 실행파일 재배포

위와 같은 흐름이 된다. 개발 프로세스에서 3번 이슈는 치명적이다. 상용 프로젝트는 빌드 한번 하는데 몇시간
씩 걸린다. 그리고 QA팀 입장에서는 프로젝트가 빌드되면 전체 검수를 다시 해야 한다.
최근에는 인터넷이 빨라져서 부담이 없긴 하지만 사용자에게 재배포 하는 이슈도 크다.

위와 같은 문제로 인해 잔머리를 굴려 만든 것이 실행시간에 링크가 가능한 동적 라이브러리이다. dll
동적 라이브러리는 링크 과정에서 간단한 정보만 남겨놓고, 실행 시간에 그 정보를 이용해 기능을 링크 하는 방식을
사용한다. 따라서 라이브러리의 기능이 변경되어도 다시 빌드할 필요 없이 간단히 라이브러리만 배포하면 된다.

이러한 동적 라이브러리는 헤더파일과 라이브러리파일 그리고 동적 라이브러리 파일을 제공한다.
동적 라이브러리의 lib는 정적 라이브러리으 ㅣ그것과는 달리 내부에 함수 본체와 같은 상세 정보는 없고 오직
정보만을 기록하고 있다. 함수 본체는 dll에 들어있다.

스택과 큐
컴퓨터는 기본적으로 입력을 받아 계산하고 출ㄹ력하는 것이다. 따라서 자료를 입력/출력으로 전달할 때나 계산에
사용할 때의 정보가 매우 중요하다. 기본 형인 정수만 사용해서는 표현 범위가 제한되기 때문에 다양한 방식을 사용하는데 
이러한 것을 자료구조하 부른다.
이러한 자료 구조 중 가장 기본적이면서 하드웨어ㅡ, 소프트웨어 구조 모두에서 사용되는 것이 스택과 큐이다.

스택
사전적으로 쌓는다는 의미다.
책을 쌓게 되면, 순서대로 위에서 부터 하나씩 꺼내야 한다. 가장 바다에 놓인 책을 뽑는 것도 않된다.
이러한 특성을 후입선출 또는 LIFO라고 한다.
스택은 가장 최근 작업이 중요한 경우에 주로 사용된다. 대표적으로 함수 호출 관리에 스택이 사용된다.

큐
사전적으로 줄을 서다라는 의미다.
가장 먼저 온 손님은 그만큼 오래 기다렸기 때문에 가장 먼저 처리해 줘야 한다.
큐는 여러 개 실행되는 작업을 순차적으로 처리할 때 사용된다. 대표적으로 윈도의 메시지 처리 및 프로세스 관리네
사용된다.
*/

/*
포인터
C,C++언어가 오랫동안 사랑받을 수 있었던 가장 큰 기능이 바로 이 포인터 이다.
하지만, 이 포인터의 문턱을 넘지 못하고 프로그램을 포기하는 경우도 많다.
가장 강력한 기능인 만큼 위험성도 매우 크다. 대부분의 게임 크러시 주범은 이녀석이기도 하다.
후속 언어들 역시 이런 포인터의 장점을 무시할 수 없다. 하지만 워낙 사용하기 까다로운 친구이므로
각자 자기들 언어에 맞게 안전한 형태로 포장해서 사용한다. 어쨌든 그 뿌리는 C언어의 포인터라는 개념이므로
이것만 잘 익혀 두면 다른 언어의 고급 기능도 쉽게 다룰 수 있다. 물론 C++이 조금 불편하네 라는 생각은 
들 수 있다.

포인터
지난 시간에 살펴 본 컴퓨터에서 변수가 처리되는 방식을 다시 한 번 살펴보자, 프로그램에서 사용하는 단순 변수는 특정 메모리의
위치(주소)에 특정한 크기(바이트)로 저장된다.
C언어 개발자는 이런 개념에서 만약, 변수의 주소에 직접 접근하면 편하겠다라는 생각을 하게된다.
우체국에서 수 많은 우편물을 효율적을 ㅗ분류하기 위해 우편번호라는 것을 도입한 것처럼

이렇게 주소를 저장할 수 있는 개념을 만들기 위해 도입된 것이 포인터이다. 포인터는 사전적 의미로 가르키고
있는 것 입니다. 즉, 컴퓨터 메모리의 어딘가를 가리킨다. 포인터는 이러한 메모리에 직접 접근함으로 써 변수를
제어한다. 이렇게 메모리의 주소를 담당하는 단항 연산자가 두개있다.

주소 연산자 & : 우측 변수의 줏를 반환한다.
포인터 연산자 * : 우측 변수가 주소를 가리키는 포인터 변수라는 것을 명시한다.

int x{ 0 } : 일반 변수 x를 선언한다.
int *p : 변수 선언에서 *을 붙이면 해당 변수가 주소를 지정할 수 있는 포인터 변수라는 것을 명시한다.
p = &x : &기호는 우측 변수의 메모리 주소를 가져오는 것이므로 p변수는 x의 주소를 가지게된다.
x = 5 : x라는 변수에 5값을 대입
std::cout<< &x : 100, x라는 변수에 현재 메모리 주소에 위치
std::cout<< p : 100, p라는 변수는 x의 메모리 주소 즉 100을 가지고 있다.
std::cout<< &p : 200, p라는 포인터 변수 역시 변수이므로 메모리에 할당되어 있으니 자신의 주소를 따로 가지고 있다.

이것이 포인터라는 개념의 기초, 여기서 중요한 것은 메모리의 주소를 가리키더라도 해당 메모리에 들어 있는 값들을 해석할 수 있다는 의미
즉 타입이다. 메모리는 연속된 공간이므로 시작 주소만으로는 데이터를 정확하게 해석할 수 없다. x라는 변수
즉, 100이라는 주소를 해석하기 위해서는 여기세 int형이 들어 있다고 알 고 있어야 4바이트만 참조해서
100이라는 숫자를 정확하게 가져올 수 있다.

int a{ 1 }, b { 2 };
int * p;
p = &a;
a의 주소를 지정해 줌으로 써 p는 a를 가리키게 된다.
p = &b;
b의 주소를 지정해 주면 p는 a와의 연결을 끊고 b를 가리킨다.
포인터 변수를 사용할 때는 * 연산자를 표시해 줘서 이 변수가 포인터임을 알려주고,
가리키고 있는 객체의 값에 접근할 수 있게 된다.
std::cout<<*p<<'\n';
p가 가리키고 있는 값을 출력하라는 의미가 되서 2가 출력된다.
포인터 변수의 특징 중 하나는 다음과 같이 변수가 가리키고 있는 곳의 값을 변경하 수 있다는 것이다.
*p = 3;

int* p; : 정수형 포인터 p의 선언
p = &b; : 포인터의 값에 b의 조수 배정
*p = 3; : p가 가리키고 있는 곳의 값에 값을 배정

&연산자를 사용하여 변수와 변수의 주소값에 대해 확인할 수 있다. 주소값은 실행환경에 따라 다르기 떄문에 매번
다른 주소일 수도 있다. 메모리 상으 ㅣ변수에 대해 조금 더 자세히 살펴보면 다음과 같이 주소, 이름, 크기와
실제 값을 가지고 있다.

포인터 변수는 타임과 상관없이 주소값만 저장하게 되므로 기본적으로 4바이트로 되어 있다.

포인터 연산

포인터 변수 역시 변수이므로 연산을 수행할 수 있다.

int a {1};
int* p = &a;

std::cout<<p;
std::cout<<p+1;
std::cout<<p+2;

가령 p가 가리키는 주소가 2000이라고 가정하자.
그럼 이 친구는 2001, 2002가 되나? 2004, 2008이 된다. 포인터 변수에서 중요한 것은 주소도 있지만 타입도
중요하다. 해당 메모리 주소를 어떻게 해석하느냐를 위한 타입이 포인터 역참조에서는 필수이기 떄문이다.
따라서 포인터의 연산은 타입의 크기 만큼 이동하게 된다.

즉, 다음과 같다.
p = p + sizeof(int) * 1;
그나마 다행인 것은 곱하기나 나누기는 지원핮 ㅣ않는다. 포인터에 대한 연산은 오직 +-만 가능하다.
이 친구가 매우 헷갈리는 개념이다.

아무것도 가르키지 않는 포인터
기본적으로 모든 변수는 초기화 될 때, 기본값이라는 상태가 있다. int라면 0,
그럼 포인터 변수도 초기값이 있다. 포인터 변수의 기본값은 널이라 부른다. 아무것도 가르키지 않는 포인터이다.
int* p{0};
널 포인터는 0이라 볼수도 있다.
int* p{NULL};
E또는 C언어 전처리기에 미리 정의된 NULL리터럴을 사용해도 된다.
C++11에서는 nullptr이라는 키워드가 준비되어 있다.
int* p{nullptr};
0으로 사용되고 있기 때문에 함수 오버로딩등에서 혼란을 가져오기 때문에 nullptr을 사용하자.

타입이 없는 포인터
기본적으로 포인터는 타입이 중요하다고 한다. 그런데 타입이 없는 친구가 있는데 그것이 void 포인터 이다.
이는 타입이 없으므로 누구나 가리킬 수 있다. 하지만 타입이 없어서 역참조가 불가능한 특성을 가지고 있다.
보이드 포인터는 다양한 타입의 변수를 지정할 수 있는 장점을 가졌다.
보이드 포인터가 역참조를 하려면 몇가지 단계가 필요하다.
(char*)p  : p는 char타입을 지정하고 있으므로 다음과 같은 형변환이 필요하다.
*(char*)p : char*에서 역참조를 수행하기 위해 별을 추가로 붙인다.

포인터의 포인터
포인터 변수는 변수의 주소값을 저장하고 있다. 그럼 포인터 변수의 주소를 처리할 수 있을까?
int a{10};
int* p = &a;
int** pp = &p;

std::cout<<a; a의 값
std::cout<<*p; a의 값
std::cout<<*(*pp); pp가 가리키는 곳의 주소가, 가리키는 곳의 값을 출력 a
std::cout<<pp<<" : "<<*pp; pp의 주소와 p의 주소

중첩된 포인터라고 하더라도 오른쪽 부터 왼쪽으로 읽어 나가면 단순히 포인터 개념일 뿐이다.

구조체와 포인터
구조체 역시 포인터로 표현할 수 있다.
struct Status
	int HP;
	int MP;

Status myStatus{100, 10};
Status* pStatus = &myStatus;

std::cout<<(*pStatus).HP;

정수형 포인터와 마찬가지로 Status형 포인터로 선언하면 된다. myStatus변수의 주소 배정함으로 초기화 할 수

구조체의 포인터가 가리키는 값을 접근할 떄는연산자 우선순위를 해결해야 한다.
구조체 멤버에 접근하는 . 연산자는 우선순위가 가장 높으며 두번째가 포인터 연산자 *이다.
따라서 *pStatus.HP라는 표현은 우선 순위에 따라 *(pStatus.HP)로 해석되기 때문에 잘못된 표현이된다.

이러한 구조체 포인터의 표현의 모호함을 없애기 위해 ->라는 구조체 포인터 연산자를 새로 정의해 주었다.
pStatus->HP

const와 포인터
프로그래밍의 편의를 위해 혹은 팀 작업의 효율을 위해 사용하는 상수라는 개념을 설명하였다.
그렇다면 만약 이 상수에 대한 포인터를 만들 수 있을까?

const int myPrecious = 10;
int* ptr = &myPrecious;
*ptr = 7;
이렇게 포인터를 통해 값을 바꿀 수 있을까?
않된다.

const int x{10}, y{20};
const int* p;
p=&x;
p=&y;
*p=1  error

const int* 라는 녀석은 가리키고 있는 곳이 상수라는 성질만 가지고 있으므로 위와 같인 드른 유형을 가리킬 수
있다. 중요한 것은 가리키고 있는 곳을 역참조로 수정할 수 없다는 특징이다.

int x{10}, y{20};
const int* ptr1;
ptr1 = &x;
int* const ptr2{&x};
ptr2=&y; errer

상수라는 개념 자체가 프로그래머의 효율성을 위해 만들어진 친구인데, 문법이 이렇게나 복잡하다.

*/

/*
포인터 활용
참조
포인터의 위력은 참조와 배열에서 쉽게 알아볼 수 있다.

값에 의한 호출, 참조에 의한 호출
지난 번 함수의 매ㅐ변수와 인자와 관계를 설명하면서 인자로 값이 복사 된다는 것을 설명했다.
따라서 인자는 매개변수와는 다른 메모리 공간의 변수로 서로 영향을 줄 수 없게된다.

두 변수의 값을 서로 바꾸는 함수가 하나 필요하다고 한다.

void swap(int x, int y)
	int temp = x;
	x = y;
	y = temp;

int main()
	int x{10}, y{20};
	swap(x,y);
	std::cout<<x<<','<<y;
위와 같이 시도해 보자, 지금까지 강의를 잘 따라왔다면 당연히 잘못 구현된 프로그램임을 알 수 있다.
x, y를 swap의 인자로 넘겨 줄 때 값이 복사가 되면서 서로 다른 변수이기 때문에 함수 내에서 변경해도 전혀 영향을 주지 않게된다.

이럴때 사용할 수 있는 것이 팜조에 의한 호출이다. 함수를 호출할 때 갑셍 의한 것이 아니라 참조를 사용한다는 의미이며,
포인터를 인자로 넘겨주는 것을 말한다.
그러면 함수 내부에서도 해당 변수를 제어할 수 있기 때문이다.

void swap(int* x, int* y)
	int temp = *x;
	*x = *y;
	* *y = temp;
	
int main()
	int x{10},y{20};
	swap(&x,&y);
	std::cout<<x<<' '<<y;

함수 선언을 위와 같이 포인터를 받도록 변경하자. 그래서 함수 내부에서는 포인터가 가르키는 곳의 값을 직접 제어한다.
함수 호출할 떄는 변수의 주소값을 넘겨준다.

만약 포인터가 없는 상황에서 다음과 같은 데이터가 있다고 가정해 보자.

struct Pixel
	char r;
	char g;
	char b;
	char a;

struct Texture
	Pixel image[100000];
	int width;
	int height;
픽셀 하나가 4바이트이므로 텍스쳐는 약 40만 바이트가 된다.

void DrawTexture(Texture t)
	Draw
int main()
	Texture t;
	DrawTexture(t);
이런 코드는 많은 메모리를 먹는다.
이때 포인터를 사용하면 된다.

C의 포인터 C++의 참조
이런 포인터는 C에서 계승된것인데 핵심 기능이었던 만큼 C++에서는 이를 조금 더 쉽게 사용할 수 있는
참조라는 타입을 추가했다.
int a{1};
int& ret = a;
ref = 3;
정수형 참조 ref 선언 및 정의, 포인터와는 달리 단순히 변수를 배정함으로 참조 변수를 정의한다.
참조형 변수의 값을 3으로 변경한다. ref가 a를 가리키고 있기 때문에 실제로는 a의 값이 3ㅡ로 변경된다.

사용은 매우 편리하지만 변수 이름만으로는 구분하기 힘들기 때문에 주의해야 한다.

선언과 동시에 반드시 초기화
	int& ref와 같이 선언만 사용할 수 없다. 반드시 선언과 함꼐 초기화해야만 한다.
초기화 이후에는 다른 변수를 참조하도록 변경 불가능
한번 초기화 한 후에는 ref = y와 같이 변경이 불가능 하다. 참조형의 특성을 잘 보면
ref = y의 y는 y의 값을 배정하는 방식이다.

위와 같은 특성으로 인해 참조형은 주로 함수의 매개변수로 자주 사용된다. 위 swap()함수를 참조형으로 사용해보자.

void swap(int& x, int& y)
	int temp =x;
	x =y;
	y=temp;
int main()
	int x{10},y{20};
	swap(x,y);
	std::cout<<x<<' '<<y;

참조와 상수
지난 시간에 포인터와 상수에 대해서 잠깐 살펴봤으니, 포인터와 유사한 C++의 참조에 대해서도 잠깐 살펴보자..
참조와 포인터는 사촌 지간이므로 기본 개념을 포인터와 크게 다르지 않다.

const int x{10};
const int& ref = x; 상수형 참조 타입이다. 포인터와는 다르니 &x로 지정하면 안된다. 참조의 특성상 선언과 동시에 초기화해야 하며 도중에 변경이 불가능 하다. 
ref = 1;	참조가 상수타입이므로 값을 변경할 수 없다.
int y{20}; 상수 포인터와 마찬가지로 상수 참조 역시 일반 유형의 변수를 참조할 수 있다.
const int& ref2 = y;
ref2 = 2;
const int& ref3 = 10 + 20; 값(포현식)을 참조할 수 있다. 우측값 참조

std::cout<<10+20;
위 코드에서 10+20의 결과인 30은 우측값이다. 따라서 해당 라인을 넘어가면 사라지는 값이다.
하지만 위에서 상수 참조로 우측값을 초기화 할 수 있으므로 더 오래 살 수 있도록 할 수 있다.
const int& ref3 { 10 + 20 };
std::cout<<ref3;

void PrintValue(const int& x)
	std::cout<<x;

int main()
	int x {10};
	PrintValue(x);
	const int y{20};
	PrintValue(y);
	PrintValue(30);
	PrintValue(40+50);

이 함수는 인자로 다양한 형태를 참조할 수 있게 된다.
아직 기본 자료형만 배워서 리터럴 혹은 값 10과 같은 것에 대한 참조가 왜 필요한지 이해가 어려울 것
하지만 최초 가의에서 객체/ 타입 / 값의 개념으로 살펴본 구조라면 해당 리터럴 역시 객체로 볼 수 있고 참조형이 가능하다
는 것 정도는 파악할 수 있다.

함수를 만들 때 내부에서 변경하지 않는다면 상수 참조를 적극 사용해보는 것이 좋다.
복사가 일어나지 않아 빠르고 코드로 의사소통하는 프로그래머들에게는 함수 시그니쳐만으로도 좋은 매뉴얼이 된다.

함수 포인터
C++에서 사용하느 함수 역시 저장 공간 RAM의 입장에서 보면 변수와 크게다를 게 없다.
int Sum(int x, int y)
Sum 식별자
int(int x, int y) 타입
식별자, 즉 오브젝트에 이름을 붙인 것은 동일한데, 타입이 조금 특이할 뿐이다. 위 Sum함수는 int를 반환하고
2개의 int 매개변수를 가지는 타입이라고 수 있다. 그렇기 때문에 함수 역시 변수와 마찬가지로 Lookup Table
을 통해 식별자를 찾는 방식을 그대로 사용하고 있다.

int Sum(int x, int y)
	return x + y;

int main()
	int x{1}, y{2};

	std::cout<<&x<<' '<<&y;
	std::cout<<&Sum<<' '<<&main;

	Sum(x,y);
로컬 변수들은 주소가 인접해 있고 함수는 조금 떨어진 곳에 인접해 있다.
오브젝트의 주소를 반환하는 &입장에서는 함수도 마찬가지다.
이렇게 프로그램 실행 중에 설정되는 변수와 실행되는 코드들은 모두 메모리에 등록되지만
서로 분리되어 관리되어진다.

이렇게 프로그램 실행 중에 설정되는 변수와 실행되는 코드들은 모두 메모리에 등록되지만 서로 분리되어 관리되어 진다.
그럼 이제 프로그램 순서도 유추해 볼 수 있다.
1. 실행 파일 더블 클릭
2. Entry Point 호출
3. 코드 실행
4. Sum(x,y)를 만나면 점프

배열과 포인터
포인터의 또 다른 장점은 내부적으로 저장된 값은 주소이므로 정수 처리할 수 있다라는 것
이러한 특징을 이용하면 배열을 처리하기 쉬워진다. 우선 배열의 각 원소별 주소값을 보자.
int arr[10]{0};
for(int i=0;i<10;i++)
	std::cout<<&arr[i]<<' ';
배열은 위와 같이 메모리 공간에서 4바이트 크기로 위와 같이 연속된 주소에 위치하고 있다.
배열의 0번째 원소를 포인터로 지정해 보자.
p = &arr[0]
이는 다음과 같다.
p = arr;
배열은 내부적으로는 포인터를 사용하고 있기 때문에 배열의 원소 표기를 때면 가장 앞 우너소를 가리키는 포인터
로 취급할 ㅅ ㅜ있다.
배열의 1번째 원소는 다음과 같이 포인터롤 지정할 수 있다.
p = &arr[1];
이는 다음과 같다.
p = arr + 1
정수형 포인터 int*라고 ㅏ입을 지정했기 때문에 P + 1은 현재 p에서 int 크기만큼 증가한 값이된다.
이러한 특성을 이용하면 배열을 탐새하는 것 역시 가능해 진다. 배열의 함게를 구하는 경우
for(int i=0;i<10;i++) sum += arr[i];
for(int i=0;i<10;i++) sum += *(arr+i);
for(int i=0,*p=arr;i<10;i++,p++) sum += *p;

2차 배열
이번에는 2차 배열을 살펴보자, 충분히 예상 가능하겠지만 간단히 2차 배열의 메모리 주소들을 찍어 보자.
int arr[2][3];
for(int i=0;i<2;i++)
	for(int j=0;j<3;j++)
		std::cout<<&arr[i][j];
	std::cout<<'\n';
표기는 2차 공간이지만, 실제로 RAM에서는 1차 공간에 펼쳐져 있는 것을 확인할 수 있다.
메모리 상으로 표기하자면 다음과 같다.
즉 2차 배열이라는 것을 배열을 원소로 가지는 배열이라고 보시면 된다.

int* p = arr; 배열은 포인터 이므로 이렇게 사용하면? 2차 배열은 에러가 난다.
int** p = arr; 이것도 에러다.
C++에서는 타입을 명확해야 하므로 잘못된 표기다.

int arr[2];
int* p = arr;
int* p = &arr[0]; 핵심은 이거다. p는 int를 가리키는 포인터 이므로 0번 원소의 주소가 되어야 한다.
즉 배열의 0번째 원소에 대한 타입으로 포인터를 만들어야 한다.
int arr[2][3]; 의 0번째 원소는 arr[0]이다. 이것은 단순히 int가 아니라 int 배열이다.
크기가 3인 배열을 가리키는 타입으로 가리켜야 한다.

int arr[2][3];
int (*p)[3] = & arr[0]; 정수를 가리키는 포인터인데 그 정수가 크기가 3인 배열

int arr[2][3][4];
int (*num)[3][4];
포인터가 배열이기 때문에 다차우너 배열은 N-1차원까지 명시해 주고 나머지 최고 차수만 배열 포인터로 전환된다.

p[i][j] = *(p[i] + j) = *(*(p+i)+j)

int arr[2][3]{
	{1,2,3},
	{4,5,6}, }
int (*p)[3] = arr;

for(int i=0;i<2;i++)
	for(int j=0;j<3;j++)
		std::cout<<*(*(p+i)+j);

(*p) p라는 변수는 3개의 정수 우너소를 가지는 배열에 대한 포인터 이다. 따라서 가로에 접근하려면 p를 역참조
해야 한다.
(*p) + j 배열을 가져왔으니 가로 원소의 위치를 찾아야 하므로 j를 더해주면 된다.
*(*p)+j)찾아낸 주소를 역참조해야 원소가 나온다.

int* p = &arr[0][0];
for(int i=0;i<2;i++)
	for(int j=0;j<3;j++)
		std::cout<<*p++<<' ';
	std::cout<<'\n';

배열의 매개변수
void Func(int param[]) 정수형 배열을 매개변수로 사용한다.
void Func(int *param) 포인터를 매개변수로 사용하낟.
두 함수는 배열과 포인터의 특성으로 동일한 의미를 가진다. 의미를 구분해서 사용하는 것이 좋다.

int sum(int input[10])
	int sum{}
	for(int i=0;i<10;i++
		sum += input[i]
이 경우 배열의 크기는 무조건 10이어야 한다.

int sum(int input[])
	int sum{};
	for(int i=0;i<10;i++)
		sum += input[i];
매개변수에는 포인터만 넘겨주므로 크기를 알 수 없다. 크기가 5이거나 20인 배열을 인자로 사용하면 준제가
발생한다.
크기를 큰 경우는 도중까지만 계산되지만, 크기가 작은 경우는 오버플로가 발생해서
치명적일 수 있다. 따라서 배열을 매개변수로 사용할 때는 꼭 크기를 같이 넘겨줘야 안전하다.
int sum(int input[], int size)
	int sum{};
	for(int i=0;i<size;i++)
		sum += input[i];

int Sum(int (*input)[3], int count)
	int sum{};
	int (*p)[3] = input;

	for(int i=0;i<2;i++)
		for(int j=0;j<3;j++)
			sum += *((*p)+j);
		p++;
	return sum;

int sum(int *input, int count)
	int sum{};
	int* p = input;
	for(int i=0;i<count;i++)
		sum += *p++;
	return sum;
int main()
	arr1[2][3]{{1,2,3},{4,5,6};
	arr2[3]{7,8,9};
	sum(&arr1[0][0], 2 * 3);
	sum(&arr2[0], 3);

int* 의 의미는 정수를 가리키는 포인터 변수라는 의미이므로 배열에 대한 어떤 정보도 가지고 있지 ㅇ낳다.

문자열과 포인터
문자열이 배열이라는 것은 간단히 살펴봣다. 배열이므로 당연히 포인터로 처리할 수 있다.

char c[6];
char* pc;
pc = &c[0];
pc는 문자열을 다루는 포인터이지만. 시작 지점만 존재한다.
pc가 문자열을 의미하려면 어디가 끝인지 반드시 알아야 ㅎㅏㄴ다.
그렇지 않으면 메모리의 남은 공간도 전부 문자열로 처리한다.
위 코드를 실행하면 다음과 같이 출력되는데, 아마 메모리 상황에 따라 더 긴 쓰레기가 붙거나 더 짧을 수도 있다.
문자열 출력이 종료되는 시점은 \0을 만날때 까지 이므로 현재 컴퓨터 상황에 따라 차이가 발생한다.

그런데 문자의 배열인 c와 문자 포인터인 pc 모두 동일한 결과를출력합니다만 메모리으 ㅣ구조를 보면 조금 다르다.
c는 배열 변수로 각 원소에 접근할 수 있는 변수이지만, pc는 c의 원소를 가리키는 주소를 저장하는 변수이다.
기본적인 개념은 다르지만 내용은 문자를 가리키는 것으로 동일하기 때문에 문자열에서 종종 오해되기도 한다.

만약 문자 배열과 문자 포인터가 같다면 다음과 같이 사용할 수 있을 것이다.
char* pc = ""
하지만 위 코드는 에러가 발생한다.
에러 내용은 const char[6]에서 char*로 변환할 수 없다는 의미이며, const가 붙어 있으니 상수라는 것이다.
char[]로 생성하면 배열로 메모리가 준비된 상태로 등록되지만 char*로 생성하면 상수로 만들어 진다는 점이 큰 차이다.

char myString[] = "safd";
char* p = myString;
조금 더 명화하게 "" 리터럴을 사용하면 NULL_Terminated문자열이 만들어지므로 깔끔해 진다.

int myInteger = 5;
char myString[] = {" is integer " };
std::cout<<myString + myInteger;
5를 더한다는 의미는 5칸을 건너 뛴다는 의미가 된다.
*/