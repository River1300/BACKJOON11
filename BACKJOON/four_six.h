#pragma once

/*
컴파일과 링크 고급
헤더파일과 소스파일
C++언어는 선언과 정의로 구분되어 있다.
보통 프로그램을 작성하다보면 상당히 많은 양의 코드를 입력하게 되며, 효율적으로 작성하기 위해 반복되는
작업들을 따로 묶어서 선언하는 경우가 많다. 또한 다른 사람이 만들어둔 편리한 기능들을 가져다 사용할 경우도
있다. 그래서, 선언과 정의를 다음과 같이 개별 파일로 묶어둔다.

헤더파일 : 함수나 변수의 선언을 모아둔 파일, 어떤 기능이 있는지, 어떤 규격인지 알려주는 용도
소스파일 : 함수나 변수의 정의를 모아둔 파일, 실제 기능을 구현하는 곳
라이브러리 파일 : 소스파일을 코드가 아닌 컴파일된 기계어로 제공하는 파일, 주로 자신이 만든 기능을 배포,
프레임 워크 처럼 한 번 만들고 자주 수정하지 않는 기능을 포함시킬 떄 사용
C++의 전신인 C언어에서는 h와 c를 사용했다. C++이 되면서 이를 구분하기 위해 많은 확장자들이 생겼지만,
이번 강의에서는 비주얼 스튜디어가 기본으로 생성하는 h와 cpp를 사용하겠다. xcode등 다른 ide를 사용하면 기본
값이 다를 수 있다.
#include 지시사
우리가 만든 다음 코드의 컴파일 및 링크를 조금더 자세히 살펴보겠다.
MyHeader.h
#pragma once

int Square(int x);
Square함수에 대한 선언이다. 헤더는 크게 사용자가 만든 헤더와 시스템 헤더로 구분된다.
시스템 헤덩 : C++언어 및 standard library에서 기본적으로 제공하는 기능들이 있다.
이러한 기능들을 시스템 헤더라 부른다. ide정확하게는 컴파일어에 기본적으로 내장되어 있다.
사용자 헤더 : 프로그래머가 직접 만든 헤터

첫번째 전처리기 지시자인 #pragma once는 단 한번만 선언하라는 의미이다. #include를 사용하여 MyHeader.h를
여러 소스파일에서 포함시킬 수 있다.이럴 켱우 중복 선언 에러가 발생할 수 있다. 따라서 중복선언을 피하기
위해 #pragma once를 명시해 줘야 한다.

MySource.cpp
#include "MyHeader.h"

int Square(int x)
	return x * x;
Square함수에 대한 저으이이다. 기존 코드들과 차이점이 있다면 #include ""이다.

#include < ... > : 시스템 헤더 파일을 포함한다.
	정확하게는 시스템에 정의되어 있는 경로에서 찾는 다는 의미이다.
#include " ... " : 사용자 헤더 파일을 포함한다.
	정확하게는 다음과같이 여러번 탐색을 한다.
	1. 현재 소스가 있는 디렉토리
	2. 현재 헤더가 있는 디렉토리
	3. 시스템에 정의되어 있는 디렉토리
약간 의미는 다르지만, 통일성을 위해 시스템 헤더는 <>, 사용자 헤더는 ""사용하면 된다.

Main.cpp
#include <iostream>
#include "MyHeader.h"

using namespace std;

int main()
	cout<<Square(2)<<'\n';
	cout<<pow(2,2)<<'\n';
시스템 헤더는 #include <iostream> / 사용자 헤더는 #include "MyHeader.h"로 구분하여 포함시킨다.

컴파일과 링크
위 예제의 컴파일과 링크 과정을 조금 살펴보자. 우선 헤더와 소스파일의 관계를 살펴보자
기본적으로 헤더 파일은 컴파일에 사용되지 않는다. 대신 소스파일의 전처리기 지시다 .#include를 통해
소스 파일에 포함된다. 전처리기라고 부르는 이유가 바로 컴파일 이전 단계에 수해되어 소스파일을 수정하기 떄문

즉, MySource.cpp를 컴파일 할때는 내부적으로 다음과 같이 된다.
int Square(int x);

int Square(int x)
	return x * x;
#include 지시자가 MyHeader.h.를 포함시키기 때문에 헤더 파일의 내용에 해당 라인에 삽입되는 것

Main역시 마찬가지

int Sqare(int x);

usinng namespace std;

int main()
	cout<<Square(2),,'n\'

iostream의 내요ㅛㅇㅇ느 엄청나게 길고, 여러개의 다른 헤더파일을 추가로 포함하고 있기 때문에
개념으로만 이해하기바란다. 주의할께 이단계에서는 함수의 선언만 포함되며, 정의는 MYSouce에 속해있다.
수동으로 컴파일을 진행해 보자
1. 빌드 > 솔루셔 정리를 눌러서 현재 프로젝트의 중간 파일들을 모두 청소한다.
2. MySource.cpp를 열고 빌드 > 컴파일을 눌러서 컴파일을 진행한다.
3. 마찬가지로 main을 열고 빌드 컴파일을 누른다.
프로젝트 폴더를 Debug라는 폴더가 있고 해당 폴더를 열어보면 컴파일 결과물을 볼 수 있다.
컴파일러가 컴파일을 성공하면 각각 MYSource.obj, main.obj라는 목적어 파일을 만들어 둔다. 목적어 파일은 헤더 파일의
내용을 포함 시킨 후 다음 단계인 링크에 필요한 정보들을 미리 모아두는 것이다.

다음 단계는 링크이다. 위에서 만들어진 목적어 파일을 연동하여 실행파일을 만든 것이 링크이다.

정적 라이브러리와 동적 라이브러리
보통 프로그램을 제작하다 보면 외부 라이브러리라는 것을 많이 사용하게 된다. 다른 개발자가 미리 만들어 둔
유용한 기능을 가져다 사용하는 방식이다. 다른 개발자가 소스를 공개할 수도 있지만, 지적 재산권 문제나
개발 속도 측면에서는 이렇게 소스를 복사하여 사용하는 것은 좋은 방식이 아니다. 따라서 컴파일이 모두 끝난 obj파일
들을 한 번에 묶어서 링크에 사용할 수 있도록 해주는 것이 라이브러리다.

정적 라이브러리
정적 라이브러리는 정적, 즉 변경할 수 없다는 의미다. 한 번 만들어진 라이프버리는 lib파일로 사용하는데
이렇게 한 번 만들어진 내부 기능은 변경할 수 있는 방법이 없다. 만약 버그 수정이나 기능 추가등으로 인해 내용을
변경해야 한다면 lib파일을 재배포 하는 방법밖에 없다.
정적 라이브러리는 보통 헤더파일과 라이브러리파일을 제공하며, 이를 각각 컴파일/링크 단계에 추가해 준다.
헤더파일은 당연히 우리의 소스 코드에 직접 include를 통해 지정해 준다.
라이브러리는 외부 종속성에 추가해 주는데 비주얼 스튜디오에서는 다음과 같이 지정해 준다.

프로젝트 > 속성 을 누르면 나타나는 설정화면으로 링커 > 입력 > 추가 종속성에 추가할 라이브러리 파일을 
넣어 주면 된다.

동적 라이브러리
정적 라이브러리는 내용이 변경되어 라이브러리 파일을 재배포해도 큰 문제가 있다. 사용자가 해당 라이브러리를 갱신
하기 위해서는 자신의 프로젝트를 다시 빌드해 줘야 합니다. 가령 다음과 같은 예를 들어 보자
1. 게임의 피명적인 버그 발견
2. 디버그 해보니 외부 라이브러리의 버그로 새로운 버전으로 업데이트 필요
3. 새로운 라이브러리를 다운 받고 프로젝트 다시 빌드
4. 사용자에게 실행파일 재배포

위와 같은 흐름이 된다. 개발 프로세스에서 3번 이슈는 치명적이다. 상용 프로젝트는 빌드 한번 하는데 몇시간
씩 걸린다. 그리고 QA팀 입장에서는 프로젝트가 빌드되면 전체 검수를 다시 해야 한다.
최근에는 인터넷이 빨라져서 부담이 없긴 하지만 사용자에게 재배포 하는 이슈도 크다.

위와 같은 문제로 인해 잔머리를 굴려 만든 것이 실행시간에 링크가 가능한 동적 라이브러리이다. dll
동적 라이브러리는 링크 과정에서 간단한 정보만 남겨놓고, 실행 시간에 그 정보를 이용해 기능을 링크 하는 방식을
사용한다. 따라서 라이브러리의 기능이 변경되어도 다시 빌드할 필요 없이 간단히 라이브러리만 배포하면 된다.

이러한 동적 라이브러리는 헤더파일과 라이브러리파일 그리고 동적 라이브러리 파일을 제공한다.
동적 라이브러리의 lib는 정적 라이브러리으 ㅣ그것과는 달리 내부에 함수 본체와 같은 상세 정보는 없고 오직
정보만을 기록하고 있다. 함수 본체는 dll에 들어있다.

스택과 큐
컴퓨터는 기본적으로 입력을 받아 계산하고 출ㄹ력하는 것이다. 따라서 자료를 입력/출력으로 전달할 때나 계산에
사용할 때의 정보가 매우 중요하다. 기본 형인 정수만 사용해서는 표현 범위가 제한되기 때문에 다양한 방식을 사용하는데 
이러한 것을 자료구조하 부른다.
이러한 자료 구조 중 가장 기본적이면서 하드웨어ㅡ, 소프트웨어 구조 모두에서 사용되는 것이 스택과 큐이다.

스택
사전적으로 쌓는다는 의미다.
책을 쌓게 되면, 순서대로 위에서 부터 하나씩 꺼내야 한다. 가장 바다에 놓인 책을 뽑는 것도 않된다.
이러한 특성을 후입선출 또는 LIFO라고 한다.
스택은 가장 최근 작업이 중요한 경우에 주로 사용된다. 대표적으로 함수 호출 관리에 스택이 사용된다.

큐
사전적으로 줄을 서다라는 의미다.
가장 먼저 온 손님은 그만큼 오래 기다렸기 때문에 가장 먼저 처리해 줘야 한다.
큐는 여러 개 실행되는 작업을 순차적으로 처리할 때 사용된다. 대표적으로 윈도의 메시지 처리 및 프로세스 관리네
사용된다.
*/

/*
포인터
C,C++언어가 오랫동안 사랑받을 수 있었던 가장 큰 기능이 바로 이 포인터 이다.
하지만, 이 포인터의 문턱을 넘지 못하고 프로그램을 포기하는 경우도 많다.
가장 강력한 기능인 만큼 위험성도 매우 크다. 대부분의 게임 크러시 주범은 이녀석이기도 하다.
후속 언어들 역시 이런 포인터의 장점을 무시할 수 없다. 하지만 워낙 사용하기 까다로운 친구이므로
각자 자기들 언어에 맞게 안전한 형태로 포장해서 사용한다. 어쨌든 그 뿌리는 C언어의 포인터라는 개념이므로
이것만 잘 익혀 두면 다른 언어의 고급 기능도 쉽게 다룰 수 있다. 물론 C++이 조금 불편하네 라는 생각은 
들 수 있다.

포인터
지난 시간에 살펴 본 컴퓨터에서 변수가 처리되는 방식을 다시 한 번 살펴보자, 프로그램에서 사용하는 단순 변수는 특정 메모리의
위치(주소)에 특정한 크기(바이트)로 저장된다.
C언어 개발자는 이런 개념에서 만약, 변수의 주소에 직접 접근하면 편하겠다라는 생각을 하게된다.
우체국에서 수 많은 우편물을 효율적을 ㅗ분류하기 위해 우편번호라는 것을 도입한 것처럼

이렇게 주소를 저장할 수 있는 개념을 만들기 위해 도입된 것이 포인터이다. 포인터는 사전적 의미로 가르키고
있는 것 입니다. 즉, 컴퓨터 메모리의 어딘가를 가리킨다. 포인터는 이러한 메모리에 직접 접근함으로 써 변수를
제어한다. 이렇게 메모리의 주소를 담당하는 단항 연산자가 두개있다.

주소 연산자 & : 우측 변수의 줏를 반환한다.
포인터 연산자 * : 우측 변수가 주소를 가리키는 포인터 변수라는 것을 명시한다.

int x{ 0 } : 일반 변수 x를 선언한다.
int *p : 변수 선언에서 *을 붙이면 해당 변수가 주소를 지정할 수 있는 포인터 변수라는 것을 명시한다.
p = &x : &기호는 우측 변수의 메모리 주소를 가져오는 것이므로 p변수는 x의 주소를 가지게된다.
x = 5 : x라는 변수에 5값을 대입
std::cout<< &x : 100, x라는 변수에 현재 메모리 주소에 위치
std::cout<< p : 100, p라는 변수는 x의 메모리 주소 즉 100을 가지고 있다.
std::cout<< &p : 200, p라는 포인터 변수 역시 변수이므로 메모리에 할당되어 있으니 자신의 주소를 따로 가지고 있다.

이것이 포인터라는 개념의 기초, 여기서 중요한 것은 메모리의 주소를 가리키더라도 해당 메모리에 들어 있는 값들을 해석할 수 있다는 의미
즉 타입이다. 메모리는 연속된 공간이므로 시작 주소만으로는 데이터를 정확하게 해석할 수 없다. x라는 변수
즉, 100이라는 주소를 해석하기 위해서는 여기세 int형이 들어 있다고 알 고 있어야 4바이트만 참조해서
100이라는 숫자를 정확하게 가져올 수 있다.

int a{ 1 }, b { 2 };
int * p;
p = &a;
a의 주소를 지정해 줌으로 써 p는 a를 가리키게 된다.
p = &b;
b의 주소를 지정해 주면 p는 a와의 연결을 끊고 b를 가리킨다.
포인터 변수를 사용할 때는 * 연산자를 표시해 줘서 이 변수가 포인터임을 알려주고,
가리키고 있는 객체의 값에 접근할 수 있게 된다.
std::cout<<*p<<'\n';
p가 가리키고 있는 값을 출력하라는 의미가 되서 2가 출력된다.
포인터 변수의 특징 중 하나는 다음과 같이 변수가 가리키고 있는 곳의 값을 변경하 수 있다는 것이다.
*p = 3;

int* p; : 정수형 포인터 p의 선언
p = &b; : 포인터의 값에 b의 조수 배정
*p = 3; : p가 가리키고 있는 곳의 값에 값을 배정

&연산자를 사용하여 변수와 변수의 주소값에 대해 확인할 수 있다. 주소값은 실행환경에 따라 다르기 떄문에 매번
다른 주소일 수도 있다. 메모리 상으 ㅣ변수에 대해 조금 더 자세히 살펴보면 다음과 같이 주소, 이름, 크기와
실제 값을 가지고 있다.

포인터 변수는 타임과 상관없이 주소값만 저장하게 되므로 기본적으로 4바이트로 되어 있다.

포인터 연산

포인터 변수 역시 변수이므로 연산을 수행할 수 있다.

int a {1};
int* p = &a;

std::cout<<p;
std::cout<<p+1;
std::cout<<p+2;

가령 p가 가리키는 주소가 2000이라고 가정하자.
그럼 이 친구는 2001, 2002가 되나? 2004, 2008이 된다. 포인터 변수에서 중요한 것은 주소도 있지만 타입도
중요하다. 해당 메모리 주소를 어떻게 해석하느냐를 위한 타입이 포인터 역참조에서는 필수이기 떄문이다.
따라서 포인터의 연산은 타입의 크기 만큼 이동하게 된다.

즉, 다음과 같다.
p = p + sizeof(int) * 1;
그나마 다행인 것은 곱하기나 나누기는 지원핮 ㅣ않는다. 포인터에 대한 연산은 오직 +-만 가능하다.
이 친구가 매우 헷갈리는 개념이다.

아무것도 가르키지 않는 포인터
기본적으로 모든 변수는 초기화 될 때, 기본값이라는 상태가 있다. int라면 0,
그럼 포인터 변수도 초기값이 있다. 포인터 변수의 기본값은 널이라 부른다. 아무것도 가르키지 않는 포인터이다.
int* p{0};
널 포인터는 0이라 볼수도 있다.
int* p{NULL};
E또는 C언어 전처리기에 미리 정의된 NULL리터럴을 사용해도 된다.
C++11에서는 nullptr이라는 키워드가 준비되어 있다.
int* p{nullptr};
0으로 사용되고 있기 때문에 함수 오버로딩등에서 혼란을 가져오기 때문에 nullptr을 사용하자.

타입이 없는 포인터
기본적으로 포인터는 타입이 중요하다고 한다. 그런데 타입이 없는 친구가 있는데 그것이 void 포인터 이다.
이는 타입이 없으므로 누구나 가리킬 수 있다. 하지만 타입이 없어서 역참조가 불가능한 특성을 가지고 있다.
보이드 포인터는 다양한 타입의 변수를 지정할 수 있는 장점을 가졌다.
보이드 포인터가 역참조를 하려면 몇가지 단계가 필요하다.
(char*)p  : p는 char타입을 지정하고 있으므로 다음과 같은 형변환이 필요하다.
*(char*)p : char*에서 역참조를 수행하기 위해 별을 추가로 붙인다.

포인터의 포인터
포인터 변수는 변수의 주소값을 저장하고 있다. 그럼 포인터 변수의 주소를 처리할 수 있을까?
int a{10};
int* p = &a;
int** pp = &p;

std::cout<<a; a의 값
std::cout<<*p; a의 값
std::cout<<*(*pp); pp가 가리키는 곳의 주소가, 가리키는 곳의 값을 출력 a
std::cout<<pp<<" : "<<*pp; pp의 주소와 p의 주소

중첩된 포인터라고 하더라도 오른쪽 부터 왼쪽으로 읽어 나가면 단순히 포인터 개념일 뿐이다.

구조체와 포인터
구조체 역시 포인터로 표현할 수 있다.
struct Status
	int HP;
	int MP;

Status myStatus{100, 10};
Status* pStatus = &myStatus;

std::cout<<(*pStatus).HP;

정수형 포인터와 마찬가지로 Status형 포인터로 선언하면 된다. myStatus변수의 주소 배정함으로 초기화 할 수

구조체의 포인터가 가리키는 값을 접근할 떄는연산자 우선순위를 해결해야 한다.
구조체 멤버에 접근하는 . 연산자는 우선순위가 가장 높으며 두번째가 포인터 연산자 *이다.
따라서 *pStatus.HP라는 표현은 우선 순위에 따라 *(pStatus.HP)로 해석되기 때문에 잘못된 표현이된다.

이러한 구조체 포인터의 표현의 모호함을 없애기 위해 ->라는 구조체 포인터 연산자를 새로 정의해 주었다.
pStatus->HP

const와 포인터
프로그래밍의 편의를 위해 혹은 팀 작업의 효율을 위해 사용하는 상수라는 개념을 설명하였다.
그렇다면 만약 이 상수에 대한 포인터를 만들 수 있을까?

const int myPrecious = 10;
int* ptr = &myPrecious;
*ptr = 7;
이렇게 포인터를 통해 값을 바꿀 수 있을까?
않된다.

const int x{10}, y{20};
const int* p;
p=&x;
p=&y;
*p=1  error

const int* 라는 녀석은 가리키고 있는 곳이 상수라는 성질만 가지고 있으므로 위와 같인 드른 유형을 가리킬 수
있다. 중요한 것은 가리키고 있는 곳을 역참조로 수정할 수 없다는 특징이다.

int x{10}, y{20};
const int* ptr1;
ptr1 = &x;
int* const ptr2{&x};
ptr2=&y; errer

상수라는 개념 자체가 프로그래머의 효율성을 위해 만들어진 친구인데, 문법이 이렇게나 복잡하다.

*/

/*
포인터 활용
참조
포인터의 위력은 참조와 배열에서 쉽게 알아볼 수 있다.

값에 의한 호출, 참조에 의한 호출
지난 번 함수의 매ㅐ변수와 인자와 관계를 설명하면서 인자로 값이 복사 된다는 것을 설명했다.
따라서 인자는 매개변수와는 다른 메모리 공간의 변수로 서로 영향을 줄 수 없게된다.

두 변수의 값을 서로 바꾸는 함수가 하나 필요하다고 한다.

void swap(int x, int y)
	int temp = x;
	x = y;
	y = temp;

int main()
	int x{10}, y{20};
	swap(x,y);
	std::cout<<x<<','<<y;
위와 같이 시도해 보자, 지금까지 강의를 잘 따라왔다면 당연히 잘못 구현된 프로그램임을 알 수 있다.
x, y를 swap의 인자로 넘겨 줄 때 값이 복사가 되면서 서로 다른 변수이기 때문에 함수 내에서 변경해도 전혀 영향을 주지 않게된다.

이럴때 사용할 수 있는 것이 팜조에 의한 호출이다. 함수를 호출할 때 갑셍 의한 것이 아니라 참조를 사용한다는 의미이며,
포인터를 인자로 넘겨주는 것을 말한다.
그러면 함수 내부에서도 해당 변수를 제어할 수 있기 때문이다.

void swap(int* x, int* y)
	int temp = *x;
	*x = *y;
	* *y = temp;
	
int main()
	int x{10},y{20};
	swap(&x,&y);
	std::cout<<x<<' '<<y;

함수 선언을 위와 같이 포인터를 받도록 변경하자. 그래서 함수 내부에서는 포인터가 가르키는 곳의 값을 직접 제어한다.
함수 호출할 떄는 변수의 주소값을 넘겨준다.

만약 포인터가 없는 상황에서 다음과 같은 데이터가 있다고 가정해 보자.

struct Pixel
	char r;
	char g;
	char b;
	char a;

struct Texture
	Pixel image[100000];
	int width;
	int height;
픽셀 하나가 4바이트이므로 텍스쳐는 약 40만 바이트가 된다.

void DrawTexture(Texture t)
	Draw
int main()
	Texture t;
	DrawTexture(t);
이런 코드는 많은 메모리를 먹는다.
이때 포인터를 사용하면 된다.

C의 포인터 C++의 참조
이런 포인터는 C에서 계승된것인데 핵심 기능이었던 만큼 C++에서는 이를 조금 더 쉽게 사용할 수 있는
참조라는 타입을 추가했다.
int a{1};
int& ret = a;
ref = 3;
정수형 참조 ref 선언 및 정의, 포인터와는 달리 단순히 변수를 배정함으로 참조 변수를 정의한다.
참조형 변수의 값을 3으로 변경한다. ref가 a를 가리키고 있기 때문에 실제로는 a의 값이 3ㅡ로 변경된다.

사용은 매우 편리하지만 변수 이름만으로는 구분하기 힘들기 때문에 주의해야 한다.

선언과 동시에 반드시 초기화
	int& ref와 같이 선언만 사용할 수 없다. 반드시 선언과 함꼐 초기화해야만 한다.
초기화 이후에는 다른 변수를 참조하도록 변경 불가능
한번 초기화 한 후에는 ref = y와 같이 변경이 불가능 하다. 참조형의 특성을 잘 보면
ref = y의 y는 y의 값을 배정하는 방식이다.

위와 같은 특성으로 인해 참조형은 주로 함수의 매개변수로 자주 사용된다. 위 swap()함수를 참조형으로 사용해보자.

void swap(int& x, int& y)
	int temp =x;
	x =y;
	y=temp;
int main()
	int x{10},y{20};
	swap(x,y);
	std::cout<<x<<' '<<y;

참조와 상수
지난 시간에 포인터와 상수에 대해서 잠깐 살펴봤으니, 포인터와 유사한 C++의 참조에 대해서도 잠깐 살펴보자..
참조와 포인터는 사촌 지간이므로 기본 개념을 포인터와 크게 다르지 않다.

const int x{10};
const int& ref = x; 상수형 참조 타입이다. 포인터와는 다르니 &x로 지정하면 안된다. 참조의 특성상 선언과 동시에 초기화해야 하며 도중에 변경이 불가능 하다. 
ref = 1;	참조가 상수타입이므로 값을 변경할 수 없다.
int y{20}; 상수 포인터와 마찬가지로 상수 참조 역시 일반 유형의 변수를 참조할 수 있다.
const int& ref2 = y;
ref2 = 2;
const int& ref3 = 10 + 20; 값(포현식)을 참조할 수 있다. 우측값 참조

std::cout<<10+20;
위 코드에서 10+20의 결과인 30은 우측값이다. 따라서 해당 라인을 넘어가면 사라지는 값이다.
하지만 위에서 상수 참조로 우측값을 초기화 할 수 있으므로 더 오래 살 수 있도록 할 수 있다.
const int& ref3 { 10 + 20 };
std::cout<<ref3;

void PrintValue(const int& x)
	std::cout<<x;

int main()
	int x {10};
	PrintValue(x);
	const int y{20};
	PrintValue(y);
	PrintValue(30);
	PrintValue(40+50);

이 함수는 인자로 다양한 형태를 참조할 수 있게 된다.
아직 기본 자료형만 배워서 리터럴 혹은 값 10과 같은 것에 대한 참조가 왜 필요한지 이해가 어려울 것
하지만 최초 가의에서 객체/ 타입 / 값의 개념으로 살펴본 구조라면 해당 리터럴 역시 객체로 볼 수 있고 참조형이 가능하다
는 것 정도는 파악할 수 있다.

함수를 만들 때 내부에서 변경하지 않는다면 상수 참조를 적극 사용해보는 것이 좋다.
복사가 일어나지 않아 빠르고 코드로 의사소통하는 프로그래머들에게는 함수 시그니쳐만으로도 좋은 매뉴얼이 된다.

함수 포인터
C++에서 사용하느 함수 역시 저장 공간 RAM의 입장에서 보면 변수와 크게다를 게 없다.
int Sum(int x, int y)
Sum 식별자
int(int x, int y) 타입
식별자, 즉 오브젝트에 이름을 붙인 것은 동일한데, 타입이 조금 특이할 뿐이다. 위 Sum함수는 int를 반환하고
2개의 int 매개변수를 가지는 타입이라고 수 있다. 그렇기 때문에 함수 역시 변수와 마찬가지로 Lookup Table
을 통해 식별자를 찾는 방식을 그대로 사용하고 있다.

int Sum(int x, int y)
	return x + y;

int main()
	int x{1}, y{2};

	std::cout<<&x<<' '<<&y;
	std::cout<<&Sum<<' '<<&main;

	Sum(x,y);
로컬 변수들은 주소가 인접해 있고 함수는 조금 떨어진 곳에 인접해 있다.
오브젝트의 주소를 반환하는 &입장에서는 함수도 마찬가지다.
이렇게 프로그램 실행 중에 설정되는 변수와 실행되는 코드들은 모두 메모리에 등록되지만
서로 분리되어 관리되어진다.

이렇게 프로그램 실행 중에 설정되는 변수와 실행되는 코드들은 모두 메모리에 등록되지만 서로 분리되어 관리되어 진다.
그럼 이제 프로그램 순서도 유추해 볼 수 있다.
1. 실행 파일 더블 클릭
2. Entry Point 호출
3. 코드 실행
4. Sum(x,y)를 만나면 점프

배열과 포인터
포인터의 또 다른 장점은 내부적으로 저장된 값은 주소이므로 정수 처리할 수 있다라는 것
이러한 특징을 이용하면 배열을 처리하기 쉬워진다. 우선 배열의 각 원소별 주소값을 보자.
int arr[10]{0};
for(int i=0;i<10;i++)
	std::cout<<&arr[i]<<' ';
배열은 위와 같이 메모리 공간에서 4바이트 크기로 위와 같이 연속된 주소에 위치하고 있다.
배열의 0번째 원소를 포인터로 지정해 보자.
p = &arr[0]
이는 다음과 같다.
p = arr;
배열은 내부적으로는 포인터를 사용하고 있기 때문에 배열의 원소 표기를 때면 가장 앞 우너소를 가리키는 포인터
로 취급할 ㅅ ㅜ있다.
배열의 1번째 원소는 다음과 같이 포인터롤 지정할 수 있다.
p = &arr[1];
이는 다음과 같다.
p = arr + 1
정수형 포인터 int*라고 ㅏ입을 지정했기 때문에 P + 1은 현재 p에서 int 크기만큼 증가한 값이된다.
이러한 특성을 이용하면 배열을 탐새하는 것 역시 가능해 진다. 배열의 함게를 구하는 경우
for(int i=0;i<10;i++) sum += arr[i];
for(int i=0;i<10;i++) sum += *(arr+i);
for(int i=0,*p=arr;i<10;i++,p++) sum += *p;

2차 배열
이번에는 2차 배열을 살펴보자, 충분히 예상 가능하겠지만 간단히 2차 배열의 메모리 주소들을 찍어 보자.
int arr[2][3];
for(int i=0;i<2;i++)
	for(int j=0;j<3;j++)
		std::cout<<&arr[i][j];
	std::cout<<'\n';
표기는 2차 공간이지만, 실제로 RAM에서는 1차 공간에 펼쳐져 있는 것을 확인할 수 있다.
메모리 상으로 표기하자면 다음과 같다.
즉 2차 배열이라는 것을 배열을 원소로 가지는 배열이라고 보시면 된다.

int* p = arr; 배열은 포인터 이므로 이렇게 사용하면? 2차 배열은 에러가 난다.
int** p = arr; 이것도 에러다.
C++에서는 타입을 명확해야 하므로 잘못된 표기다.

int arr[2];
int* p = arr;
int* p = &arr[0]; 핵심은 이거다. p는 int를 가리키는 포인터 이므로 0번 원소의 주소가 되어야 한다.
즉 배열의 0번째 원소에 대한 타입으로 포인터를 만들어야 한다.
int arr[2][3]; 의 0번째 원소는 arr[0]이다. 이것은 단순히 int가 아니라 int 배열이다.
크기가 3인 배열을 가리키는 타입으로 가리켜야 한다.

int arr[2][3];
int (*p)[3] = & arr[0]; 정수를 가리키는 포인터인데 그 정수가 크기가 3인 배열

int arr[2][3][4];
int (*num)[3][4];
포인터가 배열이기 때문에 다차우너 배열은 N-1차원까지 명시해 주고 나머지 최고 차수만 배열 포인터로 전환된다.

p[i][j] = *(p[i] + j) = *(*(p+i)+j)

int arr[2][3]{
	{1,2,3},
	{4,5,6}, }
int (*p)[3] = arr;

for(int i=0;i<2;i++)
	for(int j=0;j<3;j++)
		std::cout<<*(*(p+i)+j);

(*p) p라는 변수는 3개의 정수 우너소를 가지는 배열에 대한 포인터 이다. 따라서 가로에 접근하려면 p를 역참조
해야 한다.
(*p) + j 배열을 가져왔으니 가로 원소의 위치를 찾아야 하므로 j를 더해주면 된다.
*(*p)+j)찾아낸 주소를 역참조해야 원소가 나온다.

int* p = &arr[0][0];
for(int i=0;i<2;i++)
	for(int j=0;j<3;j++)
		std::cout<<*p++<<' ';
	std::cout<<'\n';

배열의 매개변수
void Func(int param[]) 정수형 배열을 매개변수로 사용한다.
void Func(int *param) 포인터를 매개변수로 사용하낟.
두 함수는 배열과 포인터의 특성으로 동일한 의미를 가진다. 의미를 구분해서 사용하는 것이 좋다.

int sum(int input[10])
	int sum{}
	for(int i=0;i<10;i++
		sum += input[i]
이 경우 배열의 크기는 무조건 10이어야 한다.

int sum(int input[])
	int sum{};
	for(int i=0;i<10;i++)
		sum += input[i];
매개변수에는 포인터만 넘겨주므로 크기를 알 수 없다. 크기가 5이거나 20인 배열을 인자로 사용하면 준제가
발생한다.
크기를 큰 경우는 도중까지만 계산되지만, 크기가 작은 경우는 오버플로가 발생해서
치명적일 수 있다. 따라서 배열을 매개변수로 사용할 때는 꼭 크기를 같이 넘겨줘야 안전하다.
int sum(int input[], int size)
	int sum{};
	for(int i=0;i<size;i++)
		sum += input[i];

int Sum(int (*input)[3], int count)
	int sum{};
	int (*p)[3] = input;

	for(int i=0;i<2;i++)
		for(int j=0;j<3;j++)
			sum += *((*p)+j);
		p++;
	return sum;

int sum(int *input, int count)
	int sum{};
	int* p = input;
	for(int i=0;i<count;i++)
		sum += *p++;
	return sum;
int main()
	arr1[2][3]{{1,2,3},{4,5,6};
	arr2[3]{7,8,9};
	sum(&arr1[0][0], 2 * 3);
	sum(&arr2[0], 3);

int* 의 의미는 정수를 가리키는 포인터 변수라는 의미이므로 배열에 대한 어떤 정보도 가지고 있지 ㅇ낳다.

문자열과 포인터
문자열이 배열이라는 것은 간단히 살펴봣다. 배열이므로 당연히 포인터로 처리할 수 있다.

char c[6];
char* pc;
pc = &c[0];
pc는 문자열을 다루는 포인터이지만. 시작 지점만 존재한다.
pc가 문자열을 의미하려면 어디가 끝인지 반드시 알아야 ㅎㅏㄴ다.
그렇지 않으면 메모리의 남은 공간도 전부 문자열로 처리한다.
위 코드를 실행하면 다음과 같이 출력되는데, 아마 메모리 상황에 따라 더 긴 쓰레기가 붙거나 더 짧을 수도 있다.
문자열 출력이 종료되는 시점은 \0을 만날때 까지 이므로 현재 컴퓨터 상황에 따라 차이가 발생한다.

그런데 문자의 배열인 c와 문자 포인터인 pc 모두 동일한 결과를출력합니다만 메모리으 ㅣ구조를 보면 조금 다르다.
c는 배열 변수로 각 원소에 접근할 수 있는 변수이지만, pc는 c의 원소를 가리키는 주소를 저장하는 변수이다.
기본적인 개념은 다르지만 내용은 문자를 가리키는 것으로 동일하기 때문에 문자열에서 종종 오해되기도 한다.

만약 문자 배열과 문자 포인터가 같다면 다음과 같이 사용할 수 있을 것이다.
char* pc = ""
하지만 위 코드는 에러가 발생한다.
에러 내용은 const char[6]에서 char*로 변환할 수 없다는 의미이며, const가 붙어 있으니 상수라는 것이다.
char[]로 생성하면 배열로 메모리가 준비된 상태로 등록되지만 char*로 생성하면 상수로 만들어 진다는 점이 큰 차이다.

char myString[] = "safd";
char* p = myString;
조금 더 명화하게 "" 리터럴을 사용하면 NULL_Terminated문자열이 만들어지므로 깔끔해 진다.

int myInteger = 5;
char myString[] = {" is integer " };
std::cout<<myString + myInteger;
5를 더한다는 의미는 5칸을 건너 뛴다는 의미가 된다.
*/

/*
C/C++언어의 Compile원리
right -> left
기본적으로 C++언어는 오른쪽에서 왼쪽으로 해석된다. <-
int a;
int b;
a = b = 0;
이제, 우리는 위 코드의 의미는 알지만 순서를 살펴보도록 하자. 위 코드는 다음과 같다.
a = (b = 0);
즉 b에 0을 먼저 대입한 후, a에 b를 대입하는 순서이다.

그럼 const를 한 번 살펴보자. 헷갈리므로 오른쪽에서 왼쪽으로 읽어보면된다.
영어로 만들어진 언어라 영어 표기가 좋지만 한글도 괜찬다.
const int a; a is int which is constant; a는 정수이며 상수형이다.
int const a; a is constant int; a는 상수형 정수이다.
결국 같은 의미이다.

const int* a; a is Pointer to int which is constant; a는 포인터로 정수를 가리키며 그 정수는 상수이다.
int* const b; b is constant Pointer to int; b는 상수 포인터로 정수를 가리킨다.
int const* c; c is Pointer to constant int; c는 상수 정수를 가리키는 포인터이다.

*a = 1; error a가 가리키는 정수는 상수이므로 값을 변경할 수 없다.
a++; OK a는 일반 포인터이므로 이동이 가능하다.
*b = 1; OK b는 일반 정수를 가리키므로 값을 변경할 수 있다.
b++ error b는 상수 포인터이므로 이동이 불가능 하다.
*c = 1; error c는 상수 정수를 가리미크모 값을 변경할 수 없다.
c++; OK c는 일반 포인터이므로 이동이 가능하다.

const int* 와 int const* 는 결국 같은 의미. const int와 int const가 같의 의미를 가지는 것과 동일

이런 포인터 특성 때문에 const의 위치가 중요하다.

오른쪽에서 읽기

int* (*(*fp1)(int))[10]; 의미?
C++언어가 맞나 할 정도로 복잡한 구문이다. 

우선 식별자(Identitier : 변수명, 함수명)을 가장 먼저 찾는다. : fp1
식별자의 오른쪽으로 읽어 나간다.
	단 괄호()가 있다면 우선 순위가 있으니 식별자의 왼쪽을 읽는다.
	그리고 오른쪽에 읽을 것이 없다면 끝 : (*fp1)(int) fp1은 포인터 (int) 정수를 반환하는 함수
이제 왼쪽으로 읽어 나간다. : (*(*fp1)(int)) : 인데 포인터 [10] 10개의 배열에 대한 포인터 int* 정수에 대한
fp1은 함수에 대한 포인터로 int를 매개변수로 가지고 정수에 대한 포인터 들 10개의 배열에 대한 포인터를 반환하는 함수
*/

/*
동적 메모리 관리

C++언어는 효율적ㅇ니 메모리 관리를 위해 크게 세 가지 형태를 사용한다.

1. 자동 메모리 할당 (Automatic Memory Allocation)
	지역 변수, 함수 매개변수 등은 타입으로 객체를 만들면 자동으로 타입의 크기만큼 메모리가 배정된다.
	이 친구들의 생존 주기는 블록에서 시작되고 블록에서 끝난다. 변수의 범위에서 말했다.
2. 정적 메모리 할당 (Static Memory Allocation)
	한번 만들어지면 끝까지 살아남는다는 의미로 정적이라 부른다. 즉 전역변수 및 정적 변수들이 이런 형태가된다.
3. 동적 메모리 할당 (Dynamic Memory Allocation)
	동적 즉, 프로그래머가 피료할때 만들고 제거할 수 있는 형태를 말한다.
	이 것이 바로 포인터의 핵심기능으로, 이 기능 떄문에 C라는 언어가 오랬동안 인기 있는 프로그래밍
	언어가 될 수 있었다. 이후 언어들은 모두 이러한 컨셉위에서 설계되었다.

3번의 경우는 프로그래머가 메모리를 얼마나 사용할 지를 직접 지정하는 형태로 앱이 실행될 때 결정되지만,
1,2번은 컴파일러가 알아서 해줘야 한다. 따라서 1,2,번 친구들은 컴파일 할때 그 크기를 정확하게 알 수 있어야 한다.
그렇기 때문에 다음 코드가 컴파일 에러인 것이다.
int x{5};
int numbers[x];

동적 메모리 할당
지금까지는 배열을  선언할 때 항상 명시된 크기로만 지정했는데, 가변적인 크기가 필요한 경우가 있다. 각 학급의
평균 점수를 구해야 하는데 학급별로 학생 수가 모두 다르다면 어떻게 해야 할까?
가장 쉽게 떠오르는 방법은 모든 반의 학생 수 중 가장 큰 값으로 배열을 선언하는 것이지만, 전학이 온다면?

포인터를 사용하면 원하는 크기 만큼 메모리를 언제든 만들고 없앨 수 있다. 이러한 것을 동적 메모리 할당이라 하낟.

C스타일 void* calloc(size_t num, size_t size);
배열과 같이 연속된 메모리 공간에 변수를 할당한다는 의미이다. 할당한 메모리는 0으로 초기화된다.

void* malloc(size_t size);
memory allocation의 약자로 지정한 크기 만큼 메모리를 할당한다. 이 경우는 초기화 하지 않기 때문에
calloc보다 조 더 빠르다.

void free(void* ptr);
동적 할당된 메모리를 해제한다.

함수 자체는 지정한 크기의 메모리를 할당한 후 그 주소값만 반환할 뿐이고, 프로그래머가 직접 원하는 타입에 맞게
사용해야 한다.
int* buffer1, *buffer2;

buffer1 = (int*)calloc(100, sizeof(int));
buffer2 = (int*)malloc(100 * sizeof(int));

if(buffer1 && buffer2)
	std::cout<<buffer1[2]<<','<<*buffer2;
	free(buffer1);
	free(buffer2);

C++스타일
C의 동적 메모리 관리 역시 핵심 기능이므로 C++에서는 함수가 아닌 연산자로 이러한 기능을 제공한다.

포인터변수 = new 타입; new연산자는 주어진 타입으로 메모리 공간을 할당한 후 돌려 주는 단항 연산자이다.
delete 포인터변수; delete 연산자는 주어진 포인터 변수의 메모리를 해제하는 당항 연산자이다.
포인터 변수 = new 타입[크기]; 배열 형태로 메모리를 할당하는 new[]연산자이다.
delete[] 포인터 변수; 배열 형태로 할당한메모리를 해재하는 delete[] 연산자이다.

int* pNew{};

pNew = new int;
*pNew = 4;

delete pNew;

int* pNew{ new int{ 4 } };

struct Student
	int number;
	char name[16];

Student* allocated = new Student;
allocated->number = 1;

delete allocated;

Student* array = new Student[5];

array[0].number = 1;
array[1].number= 2;

delete[] array;

주의 사항 
동적 메모리를 사용할 때는 다음 세가지를 명심하기 바라낟.
1. 메모리 누수
	동적으로 할당만하고 해제하지 않으면 해당 메모리는 프로그램이 종료되어 운영체제로 반환되기 전까지
	지워지지 않느낟. 게임을 오래하다보면 느려지는 현상을 보셧나, 이런 경우가 대부분 메모리 누수로
	인해 메모리가 부족한 경우이다. 동적 메모리를 사용할 때는 항상 할당/해제 코드를 미리 장서하는 습관

2. new도 실패할 수 있다.
	게임을 개발하다 보면, 메모리가 부족한 경우가 상당히 만다. 따라서 이러한 경우 윈도가 뻗어 버리지 않게
	예외 처리를 꼭 해줘야 한다.
	if(buffer1){...}
	위와 같은 표현도 익숙해 지기 바란다. 포인터 자체는 정수값이므로 비교식의 조건으로 사용할 경우 자동적으로 참/거짓
	으로 판정이 가능하다. 위 표현은 포인터가 널이면 거짓으로 그 이외 정상적으로 할당되면 참이 되는 것

3. 해제한 메모리
	오해의 소지가 있지만 해제는 실제로 메모리를 삭제하는 것이 아니라 내용은 그대로 두고 lookup 테이블에서
	지워서 운영체제로 메모리로 돌려주는 것 뿐디ㅏ.
	이미 해제한 메모리를 다시 해제하려고 시도하면 어떤 경우는 프로그램만이 아닌
	위도 전체를 마비시킬 정도록 심각한 무제를 발생시킨다.
	따라서 메모리를 해제한 후 초기값 nullptr로 할당해 두는 것이 좋다.

nullptr과 delete
1번에 따르면 new도 실패할 수 있다. 따라서 메모리를 해제할 때 현재 메모리가 안전한지는 체크해야 할 필요가 있다.

if(pNew != nullptr)
	delete pNew;

if(pNew)
	delte pNew;

그런데 nullptr이라는 리터럴은 메모리가 할당되지 않았다 라는 의미도 가지고 있다.
따라서 다음과 같이 사용해도 된다.
delete pNew;
pNew가 nullptr이 아니라면, 즉 정상적으로 할당된 메모리라면 자동적으로 해제한다. 만야 pNew가 nullptr이라면
할당된적 없으므로 아무런 행동도 수행하지 않는다.

인터넷 및 교제 코드들은 첫번째 두번째 경우들을 주로 사용하는데 사실 큰 의믜가 없는 코드들인것이다.
C++에서는 동적 메모리를 해제할 때 nullptr을 체크하지 않고 그냥 지워도 된다.

dangling Pointer
해제한 메모리에 대해서 조금 더 살펴 보자. 재미있는 코드 같지만 다음 친구는 매우 위험하다.
int* p = new int;
p = new int;

p를 두 번 할당해 버리면 최초에 할당한 녀석을 알 수 있는 방법이 없다. 즉 해제할 수 없어서 메모리 누수가 발생
동일한 변수를 사용할 때는 꼭 먼저 해제한 후에 사용해야 한다.

힙 스택
동적 메모리를 사용하는 또 다른 경우는 데이터를 힙에 등록해야 할 경우이다. 스택은 매우 작은 메모리를 
사용하기 때문에 매우 큰 데이터는 지역 변수로 사용할 없다.

지난 번 참조를 다룰 때 잠깐 설명했다. 이건 근본적으로 로컨 변수로 할당할 수 없다.
Texture 구조체는 지ㅣ역 변수이므로 Stack에 할당해야 하는데 tex자체가 4바이트 * 1000000이 된다.
즉 스택 메모리가 넘치는 스택오버플로 에러가 발생하게 된다. 이러케 큰 데이터는 Heap에 등록해야 한다.

동적 배열
배열을 동적으로 만드는 경우가 가장 많다.
할당 : 포인터 변수 = new int[];
해제 : delete[] 포인터변수;

사용자에게 배열의 크기를 입력받아서 해당 크기의 배열을 생성한 후 값을 모두 1로 초기화 해보자.
int inputSize{};

std::cout<<"배열의 크기는? " ;
std::cin>>inputSize;

if(inputSize <= 0)
	std::cout<<"잘못된 크기입니다.\n";
	return 0;
int* pArray = new int[inputSize]; // 동적 할당이므로 변수 사용 가능
for(int i =0; i< inputSize; i++)
	pArray[i] = 1;
delete[] pArrayy;
pArray = nullptr;

size_t
위 코드에서 배열의 크기를 저장하는 inputSize를 생각해보자. 배열의 크기를 지정하는 용도로 사용하는데
음수가 가능한 int는 위험한 타입이ㅣ다. unsigned int와 같이 양수가 안전한 타입이다.
C++에서는 size_t라는 메모리의 크기와 관련된 타입을 새로 만들어 뒀다. 물론 저장되는 값은 내부적으로 양수
이며 32비트 4바이트 64비트 8파바이트로 메모리 지원에 최적화 되어있다. int 는 32, 64모두 4바이트다.
기본적으로 new[]연산자는 sie_t를 받도록 설계되어 있으며 위 코드는 암시적 형변환이 자동으러 일어나게 되는 것
이다. 앞으로 언급할 C++표준 라이브러리들 역시 크기 관련은 모두 size_t를 사용하므로 간단히 개념만
알고 있으면된다.

당연히 위 코드는 간단히 1로 초기화하는 간단한 기능인데 매우 짜증나다. 크기가 5인 경우는 유니폼 초기화힉이면
당연히 간단히 만들 수 있다.
만약 inputSize의 값이 6이면 어떻게 될까? 나머지는 기본값이 0이된다.
만약 값이 3이라면 동적으로 할당한 공간은 3칸인된 초기화를 5개원소에 접근하려고 하므로 에러이다.
따라서 동적 배열은 유니폼 초기화힉을 사용할때 주의해야 하낟.
원소의 크기와 상관없는 다음과 같은 초기화 표현을 주로 한다.

동적 2차 배열
위에서 2차 배열에 대한 포인터를 한 번 살펴 봤는데, 이번엔 동적 2차 배열을 다뤄 보자.
지나 시간 2차 배열을 포인터로 지정하는 과정을 다시 떠올려 보자.
즉 2차 배열을 포인터로 변환하기 위해서는 1차의 크기를 지정해 줘야만 했다.

그런데 동적 배열은 어떤가? 배열의 크기가 모두 가변이므로 정확한 타입이 ㅇ벗다. 따라서 이번에는 다음
개념을 그대로 사용할 수 엤게 된다.

int number =5;
int* p = &number;
std::cout<<p<<" : "<<*p<<std::endl;
int** pp = &p;
std::cout<<pp<<" : "<<*pp<<" : "<<**PP;
p는 number의 주소를 가지고 있다.
*p는 역참조로 number의 값을 가져온다.
pp는 p의 주소를 가지고 있다.
*pp는 역참조로 p의 값을 가지고 있으니, number의 주소가 될것
**pp는 p의 역참조가 number의 주소이므로 다시 역참조 해서 number의 값을 가지게된다.

단계가 하나 더 있을 분 기본적인 포인터 개념에서 크게 바뀐 것은 없다.

inr** pp = &&number; error

number : 값 5를 저장하고 있는 변수 좌측값
&number : number의 주소를 의미라는 리터럴 우측값
&(&number) : &주소값이라는 표현이 되어 버려서 처리 불가

int** array = new int[2][3]; error
int (*array)[3] = new int[2][3]
하지만, 이런 표기는 진정한 의미에서 동적 배열이 아니다. 배열의 갯수가 불확실한 상황에서 필요할 때마다 만들어
야 하는데, 위 선언은 가로 크기를 무조건 고정해야만 사용이 가능하다.
따라서 진정한 의미로 2차원 배열을 동적 배열로 만들기 위해서는 복잡한 과정을 거쳐야 한다. 동적 1차원
배열의 동적 1차원 배열로 말이다.

int** array = new int* [2];
for(int i=0;i<2;i++)
	array[i] = new int[3];

main() 함수
지난 시간 간단히 원형만 살펴보고 넘어갔다. 이제 우리는 main함수를 제댈로 이해할 수 있다.
int main()
int main(int argc, char* argv[])
int argc = argument count의 약자로 매개변수 갯수를 지정한다.
cahr* argv[] = argument vector의 약자로 매개변수 목록이다. 타입에서 힌트를 얻자면 char[]의 *이므로 문자열 포인터
즉 문자열의 배열 형태라는 것을 알 수 있다.

명령줄 인수라는 개념이 있다. 앱을 실행할 때 미리 옵션을 지정할 수 있는 개념이다.
예전에는 DOS라는 환경에서 다음과 같이 넘겨줬다.
C:\>MyGame /Game/Maps/MyMap/ -NoVSync -FULLSCREEN -FPS
게임에서 사용하는 옵션들을 프로그램을 실행할 때 지정해 주는 방식을 사용한 것
요즘은 Window에서 바로가리를 통해 설정 가능하다.

이런 기능은 앱을 시작할 때 개발자가 지정한 옵션을 적용하여 프로그램을 구동시키기 위합니다. 
요즘은 보통 게임화면 내의 옵션에서 다루기 때문에 자주 사용되지는 안흔다.
이 기능의 핵심은 옵션을 여러 개의 문자열로 넘겨준다는 점으로 이 옵션은 진입점인 main함수에 직접
매개 변수로 전달해 준다.
문자열의 배열이므로 배열의 갯수와 문자열 배열에 대한 매개 변수가 필요하므로 다음과 같은 형태가 된다.





*/