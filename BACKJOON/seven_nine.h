#pragma once

/*
오류
오류의 종류

컴파일 시간 오류(CompileTimeError)
컴파일러가 찾아 낸 오류로 가장 수정하기 쉬운 오류다.
	문법 오류, 타입 오류
링크 시간 오류(LinkTimeError)
링커가 탐지한 오류로 역시 수정하기 쉽다. 주로 외부 라이브러리의 잘못된 사용으로 발생한다.
실행 시간 오류(RunTimeError)
프로그램을 실행하는 동안 발생하는 오류로 프로그래머가 용의주도하고 꼼꼼하다면 그나마 수정하기 귑다.
	컴퓨터가 감지한 오류 : 컴퓨터가 허용하지 않는 계산을 하려고 할 때 발생
	라이브러리가 감지한 오류 : 라이브러리가 혀용하지 않는 계산에서 발생
	사용자가 감지한 오류 : 프로그래머가 직접 허용되지 않는 계산을 지정하고, 오류를 발생
논리 오류
찾기 가장 어려운 오류/ 입력 -> 연산 -> 결과 모두 문제 없이 실행되는데, 결과가 다름

오류의 원인

잘못된 명세
	프로그램 명세를 프로그램의 목적과 해야할 일을 명시하는 것
	기획서에서 바로 시작하는 경우도 많다. 이러한 명세서에 논리적인 결함이 있을 경우 그대로 구현한 프로그램은 당연히
	오류를 가지고 있다.
불완전한 프로그램
	처음부터 불완전하게 프로그램을 개발하는 프로그래머는 없다. 다만 개발 과정은 시간과의 싸움인지라 부족한
	시간에 쫓기다 보면 어쩔 수 없이 급하게 코딩하는 경우가 생기고 오류가 발생할 수 있다.
예상 밖의 인자
	함수에 사용되는 입력은 주의해야 한다. 나이를 입력 받아 계산하는 함수가 -1과 같이 음수가 매개 변수로 전달되면 어ㄸㄹ가
	문자열을 인자로 받는 함수가 빈 문자열을 받으면
예상 밖의 입력
	프로그램은 주로GUI를 이용해 사용자와 상호 작용한다.
	정수를 입력 받는데 사용자가 문자열을 입력한다거나, 다른 작업을 진행 중에 버튼을 누른다거나 하는 상황이 언제
	든지 발생할 수 있다. 사용자는 절대로 프로그래머나 기획자가 의도한대로 행동하지 안는다.
예상 밖의 상태
	주어진 입력을 계산하기 위해 배열을 사용하고 있다고 가정해 보자, 그런데 이 배열의 내용이 잘못되었다면? 당연히 결과도
	잘못 나올 것이다. 이렇게 계산을 위해 숨겨진 자료 구조는 프로그램을 작성할 때 눈으로 볼 수 ㅇ벗기 때문에 익숙해 지기
	전까지 실수할 가능일서 높다.
논리 오류
	
컴파일 시간 오류
최근 컴파일러는 거의 실시간으로 컴파일 에러를 잡아 주기 때문에 문법 실수, 오타등은 손쉽게 파악할 수 있다.
다만, 에러 메세지는 그리 친절하지 않다.
	오류 : 오류가 발생하면 컴파일이 더이상 진행되지 안흔다.
	경고 : 경고는 컴파일이 성공적으로 진행되고, 프로그램도 실행할 수있다.
	하지만 의도치 않은 결과가 나올 수 있다.

링크 시간 오류
	링크 과정에 발생하는 오류로 조금 어렵긴 하지만 코드를 훑어보면 찾을 수 있다.

예외
	지금까지 살펴본 오류에 대한 처리를 지원하는 것이 예외이며, 예외는 다음과 같이 구성되어 있다.
		오류 발생
			함수가 처리할 수 없는 오류가 발생하면 이를 프로그래머가 인지해서 일반적인 return이 아닌
			예외를 던진다.
		예외 탐지 및 처리
			함수를 직간접적으로 호출한 모든 쪽에서 계산을 시도해보고 예외를 잡아내서 해당 예외에
			대한 처리를 수행

double linear_equation(int a, int b)
	if(a == 0)
		throw std::logic_error("divide by zero!");
	return -((double)b / a);
int main()
	int a;
	int b;
	std::cout<<"두 정수를 입력하세요 : ";
	std::cin>> a >> b;

	try
		std::cout<<linear_equation(a, b);
	catch(std::logic_error)
		std::cerr<< "Divede by zero!";
프로그래머가 계산에서 오류를 탐지하고 logic_error 예외를 던진다.
함수를 사용하기 전에 try{} 구문으로 계산을 시도한다.
try블록에서 던져진 예외를 catch 한다.
예외 대응
예외를 사용하면 지금까지의 오류 처리해 비해 안전하게 처리할 수 있으며, 오류 감지와 처리가 명확하게
분리될 수 있다. 예외에 대한 C++ 사용법은 매우 복잡하고 다양하다.

기본 예외 처리

int main()
	try
		// your code
		return 0;
	catch(std::exception e)
		std::cerr<< "error : "<< e.what();
		return 1;
	catch(...)
		std::cerr<<"unknown error!";
		return 2;
*/

/*
GitHub

형상 관리 SCM
소프트웨어 구성 관리라고도 부르는 이 기능은 프로젝트의 변경 사항을 체계적으로 추적하고 관리하기 위한
것으로 소스 코드의 버전 관리를 포함한 빌드 구조, 개발 환경 등 프로그래밍에 필요한 전반적인 기능들을 모두 모아둔 시스템을 말한다.

형상 관리란 소프트웨어 개발에서 소스 코트나 문서 등의 변경 사항을 관리하는 일련의 프로세스와 도구를 말한다.
SCM은 여러 개발자가 동시에 작업하고 있는 프로젝트에서 중요한 역할을 한다.

일반적으로 SCM 시스템은 소스 코드를 저장하고 관리하며, 소스 코드의 버전을 추적하고, 변경 내용을 검토하고,
변경 이력을 추적하고, 다양한 브랜치를 만들어 다른 버전을 관리할 수 있다. 또한 SCM은 다양한 협업 도구를 제공한다.
예를 들어 여러 개발자가 동시에 작업하고 있는 경우, SCM은 다른 개발자의 작업과 충돌하지 않도록 하기 위해
코드를 통합하고 충돌을 해결하는 도구를 제공한다.

SCM 시스템은 소프트웨어 개발에서 필수적인 도구 중 하나이며, 팀의 협업과 프로젝트의 효율성을 높이는 데
큰 역할을 한다. 대표적인 SCM 시스템으로는 Git, SVN, Mercurial이 있다.

브랜치는 SCM에서 프로젝트를 관리하는 방법 중 하나이다. 브랜치는 특정 시점에서 현재 코드 베이스에서
분기하여 새로운 버전의 코드를 만드는 것이다. 이렇게 만들어진 브랜치는 독립적인 코드 베이스를 가지게 되며, 다른 브랜치와는
독립적으로 변경 사항을 추가하고 관리할 수 있다.

예를 들어, 여러 개발자들이 동시에 작업을 진행하면서 브랜치를 사용할 수 이있다. 각 개발자는 자신이 담당하는
기능 개발을 위한 브랜치를 만들어서 코드 변경 작업을 수행합니다. 이렇게 만들어진 브랜치는 다른 개발자으 ㅣ작업
과는 독립적으로 변경 사항을 추가하고 관리할 수 있다. 이 후에 브랜치에서 변경된 내용을 다시 메인 브랜치에
병합하여 전체 코드 베이스에 반영할 수 있다.

브랜치는 SCM에서 개발자들이 작업을 더욱 효과적으로 관리할 수 있도록 도와준다. 브랜치를 적절히 활용하면 다양한 기능
개발과 버그 수정 등을 병행하며, 개발 작업을 보다 안정적이고 체계적으로 수행할 수 있다.

버전 관리 시스템 VSS
로컬 방식
	말그대로 사용자의 컴퓨터에 저장하는 것입니다.가장 기본적인 방법이므로 사용하기 쉽지만, 다른 사람과의
	협업에서는 불편할 수 밖에 없다. 개인 컴퓨터에만 저장되므로 백업같은 수단이 없어 안정성도 매우 떨어진다.
서버 방식
	모든 소스 코드는 서버에 저장된다. 프로그래머들은 각 이 서버에 접속해서 수정을 원하는 코드를 받아 온
	다음 로컬에서 작업을 수행한다. 작업이 끝나면 본인의 코드를 서버로 올린다.
클라우드 방식
	서버에 저장되는 형태는 동일하지만 프로그래머들은 각자 자신의 컴퓨터에도 동일한 프로젝트 사본을 한 벌씩
	가지고 있다. 작업이 끝나면 본인의 프로젝트와 서버의 프로젝트를 동기화 한다.
VSS는 Visual SourceSafe의 약자로, 마이크로소프트에서 개발한 소스트웨어 버전 관리 시스템이다.
이 시스템은 개발자나 팀이 소스 코드나 문서, 바이너리 파일 등의 변경 내역을 추적하고 관리할 수 있도록 지원한다.

VSS는 파일 레벨에서 변경 이력을 추적하며, 이전 버전으로 롤백할 수 있고 여러 사용자가 동시에 작업하면
충돌을 방지하기 위해 파일 잠금 기능을 제공한다.
또한 백업 및 복원 기능도 제공하여, 소스 코드나 문서 등이 손상되거나 삭제되었을 때 데이터를 복구할 수 있다.

하지만 VSS는 오래 전에 개발된 시스템으로 최신 기술과 트랜드에 비해 기능이 제한적이며, 대규모 프로젝트에 적합하지 않을 수 있다.
따라서 최근에는 Git, Subversion 등의 다른 버전 관리 시스템이 보다 많이 사용되고 있다.

Git & GitHub

*/