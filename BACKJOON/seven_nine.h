#pragma once

/*
오류
오류의 종류

컴파일 시간 오류(CompileTimeError)
컴파일러가 찾아 낸 오류로 가장 수정하기 쉬운 오류다.
	문법 오류, 타입 오류
링크 시간 오류(LinkTimeError)
링커가 탐지한 오류로 역시 수정하기 쉽다. 주로 외부 라이브러리의 잘못된 사용으로 발생한다.
실행 시간 오류(RunTimeError)
프로그램을 실행하는 동안 발생하는 오류로 프로그래머가 용의주도하고 꼼꼼하다면 그나마 수정하기 귑다.
	컴퓨터가 감지한 오류 : 컴퓨터가 허용하지 않는 계산을 하려고 할 때 발생
	라이브러리가 감지한 오류 : 라이브러리가 혀용하지 않는 계산에서 발생
	사용자가 감지한 오류 : 프로그래머가 직접 허용되지 않는 계산을 지정하고, 오류를 발생
논리 오류
찾기 가장 어려운 오류/ 입력 -> 연산 -> 결과 모두 문제 없이 실행되는데, 결과가 다름

오류의 원인

잘못된 명세
	프로그램 명세를 프로그램의 목적과 해야할 일을 명시하는 것
	기획서에서 바로 시작하는 경우도 많다. 이러한 명세서에 논리적인 결함이 있을 경우 그대로 구현한 프로그램은 당연히
	오류를 가지고 있다.
불완전한 프로그램
	처음부터 불완전하게 프로그램을 개발하는 프로그래머는 없다. 다만 개발 과정은 시간과의 싸움인지라 부족한
	시간에 쫓기다 보면 어쩔 수 없이 급하게 코딩하는 경우가 생기고 오류가 발생할 수 있다.
예상 밖의 인자
	함수에 사용되는 입력은 주의해야 한다. 나이를 입력 받아 계산하는 함수가 -1과 같이 음수가 매개 변수로 전달되면 어ㄸㄹ가
	문자열을 인자로 받는 함수가 빈 문자열을 받으면
예상 밖의 입력
	프로그램은 주로GUI를 이용해 사용자와 상호 작용한다.
	정수를 입력 받는데 사용자가 문자열을 입력한다거나, 다른 작업을 진행 중에 버튼을 누른다거나 하는 상황이 언제
	든지 발생할 수 있다. 사용자는 절대로 프로그래머나 기획자가 의도한대로 행동하지 안는다.
예상 밖의 상태
	주어진 입력을 계산하기 위해 배열을 사용하고 있다고 가정해 보자, 그런데 이 배열의 내용이 잘못되었다면? 당연히 결과도
	잘못 나올 것이다. 이렇게 계산을 위해 숨겨진 자료 구조는 프로그램을 작성할 때 눈으로 볼 수 ㅇ벗기 때문에 익숙해 지기
	전까지 실수할 가능일서 높다.
논리 오류
	
컴파일 시간 오류
최근 컴파일러는 거의 실시간으로 컴파일 에러를 잡아 주기 때문에 문법 실수, 오타등은 손쉽게 파악할 수 있다.
다만, 에러 메세지는 그리 친절하지 않다.
	오류 : 오류가 발생하면 컴파일이 더이상 진행되지 안흔다.
	경고 : 경고는 컴파일이 성공적으로 진행되고, 프로그램도 실행할 수있다.
	하지만 의도치 않은 결과가 나올 수 있다.

링크 시간 오류
	링크 과정에 발생하는 오류로 조금 어렵긴 하지만 코드를 훑어보면 찾을 수 있다.

예외
	지금까지 살펴본 오류에 대한 처리를 지원하는 것이 예외이며, 예외는 다음과 같이 구성되어 있다.
		오류 발생
			함수가 처리할 수 없는 오류가 발생하면 이를 프로그래머가 인지해서 일반적인 return이 아닌
			예외를 던진다.
		예외 탐지 및 처리
			함수를 직간접적으로 호출한 모든 쪽에서 계산을 시도해보고 예외를 잡아내서 해당 예외에
			대한 처리를 수행

double linear_equation(int a, int b)
	if(a == 0)
		throw std::logic_error("divide by zero!");
	return -((double)b / a);
int main()
	int a;
	int b;
	std::cout<<"두 정수를 입력하세요 : ";
	std::cin>> a >> b;

	try
		std::cout<<linear_equation(a, b);
	catch(std::logic_error)
		std::cerr<< "Divede by zero!";
프로그래머가 계산에서 오류를 탐지하고 logic_error 예외를 던진다.
함수를 사용하기 전에 try{} 구문으로 계산을 시도한다.
try블록에서 던져진 예외를 catch 한다.
예외 대응
예외를 사용하면 지금까지의 오류 처리해 비해 안전하게 처리할 수 있으며, 오류 감지와 처리가 명확하게
분리될 수 있다. 예외에 대한 C++ 사용법은 매우 복잡하고 다양하다.

기본 예외 처리

int main()
	try
		// your code
		return 0;
	catch(std::exception e)
		std::cerr<< "error : "<< e.what();
		return 1;
	catch(...)
		std::cerr<<"unknown error!";
		return 2;
*/

/*
GitHub

형상 관리 SCM
소프트웨어 구성 관리라고도 부르는 이 기능은 프로젝트의 변경 사항을 체계적으로 추적하고 관리하기 위한
것으로 소스 코드의 버전 관리를 포함한 빌드 구조, 개발 환경 등 프로그래밍에 필요한 전반적인 기능들을 모두 모아둔 시스템을 말한다.

형상 관리란 소프트웨어 개발에서 소스 코트나 문서 등의 변경 사항을 관리하는 일련의 프로세스와 도구를 말한다.
SCM은 여러 개발자가 동시에 작업하고 있는 프로젝트에서 중요한 역할을 한다.

일반적으로 SCM 시스템은 소스 코드를 저장하고 관리하며, 소스 코드의 버전을 추적하고, 변경 내용을 검토하고,
변경 이력을 추적하고, 다양한 브랜치를 만들어 다른 버전을 관리할 수 있다. 또한 SCM은 다양한 협업 도구를 제공한다.
예를 들어 여러 개발자가 동시에 작업하고 있는 경우, SCM은 다른 개발자의 작업과 충돌하지 않도록 하기 위해
코드를 통합하고 충돌을 해결하는 도구를 제공한다.

SCM 시스템은 소프트웨어 개발에서 필수적인 도구 중 하나이며, 팀의 협업과 프로젝트의 효율성을 높이는 데
큰 역할을 한다. 대표적인 SCM 시스템으로는 Git, SVN, Mercurial이 있다.

브랜치는 SCM에서 프로젝트를 관리하는 방법 중 하나이다. 브랜치는 특정 시점에서 현재 코드 베이스에서
분기하여 새로운 버전의 코드를 만드는 것이다. 이렇게 만들어진 브랜치는 독립적인 코드 베이스를 가지게 되며, 다른 브랜치와는
독립적으로 변경 사항을 추가하고 관리할 수 있다.

예를 들어, 여러 개발자들이 동시에 작업을 진행하면서 브랜치를 사용할 수 이있다. 각 개발자는 자신이 담당하는
기능 개발을 위한 브랜치를 만들어서 코드 변경 작업을 수행합니다. 이렇게 만들어진 브랜치는 다른 개발자으 ㅣ작업
과는 독립적으로 변경 사항을 추가하고 관리할 수 있다. 이 후에 브랜치에서 변경된 내용을 다시 메인 브랜치에
병합하여 전체 코드 베이스에 반영할 수 있다.

브랜치는 SCM에서 개발자들이 작업을 더욱 효과적으로 관리할 수 있도록 도와준다. 브랜치를 적절히 활용하면 다양한 기능
개발과 버그 수정 등을 병행하며, 개발 작업을 보다 안정적이고 체계적으로 수행할 수 있다.

버전 관리 시스템 VSS
로컬 방식
	말그대로 사용자의 컴퓨터에 저장하는 것입니다.가장 기본적인 방법이므로 사용하기 쉽지만, 다른 사람과의
	협업에서는 불편할 수 밖에 없다. 개인 컴퓨터에만 저장되므로 백업같은 수단이 없어 안정성도 매우 떨어진다.
서버 방식
	모든 소스 코드는 서버에 저장된다. 프로그래머들은 각 이 서버에 접속해서 수정을 원하는 코드를 받아 온
	다음 로컬에서 작업을 수행한다. 작업이 끝나면 본인의 코드를 서버로 올린다.
클라우드 방식
	서버에 저장되는 형태는 동일하지만 프로그래머들은 각자 자신의 컴퓨터에도 동일한 프로젝트 사본을 한 벌씩
	가지고 있다. 작업이 끝나면 본인의 프로젝트와 서버의 프로젝트를 동기화 한다.
VSS는 Visual SourceSafe의 약자로, 마이크로소프트에서 개발한 소스트웨어 버전 관리 시스템이다.
이 시스템은 개발자나 팀이 소스 코드나 문서, 바이너리 파일 등의 변경 내역을 추적하고 관리할 수 있도록 지원한다.

VSS는 파일 레벨에서 변경 이력을 추적하며, 이전 버전으로 롤백할 수 있고 여러 사용자가 동시에 작업하면
충돌을 방지하기 위해 파일 잠금 기능을 제공한다.
또한 백업 및 복원 기능도 제공하여, 소스 코드나 문서 등이 손상되거나 삭제되었을 때 데이터를 복구할 수 있다.

하지만 VSS는 오래 전에 개발된 시스템으로 최신 기술과 트랜드에 비해 기능이 제한적이며, 대규모 프로젝트에 적합하지 않을 수 있다.
따라서 최근에는 Git, Subversion 등의 다른 버전 관리 시스템이 보다 많이 사용되고 있다.

Git & GitHub
Git은 분산 버전 관리 시스템이다. 개발자들이 소스 코드와 같은 파일을 저장하고 관리하는 데 사용된다. 
Git을 사용하면 여러 명의 개발자가 동시에 작업하고, 작업 내용을 추적하며, 이전 버전으로 되돌리는 등의 작업을
할 수 있다.

GitHub는 Git을 사용하는 웹 기반 호스팅 서비스이다. 개발자들은 GitHub를 사용하여 자신의 Git 저장소를 호스팅하고,
다른 개발자들과 협력하여 작업을 할 수 있다. GitHub는 오픈 소스 프로젝트를 호스팅하는 데 매우 인기 있다.

GitHub를 사용하면 다른 개발자들과 협력하여 코드를 컴토하고, 수정하고, 결합할 수 있다.
또한 이슈 트래커를 사용하여 버그를 추적하고 기능 요청을 관리할 수 있다.
GitHub는 커뮤니티 기반 개발을 촉진하며, 개발자들이 다양한 오픈 소스 프로젝트에 기여하는 것을 돕는다.

Git과 GitHub는 현대 소프트웨어 개발의 중요한 부분이 되어, 프로그래머들은 이를 알고 있어야 한다.

저장소(Repository)
	저장소는 파일, 문서, 코드 및 기타 프로젝트 자산의 버전을 관리하는 데 사용된다. 저장소는 Git 또는 GitHub에서
	생성할 수 있다.
	Git에서 저장소는 로컬 컴퓨터에 있는 디렉토리이다. 이 디렉토리는 Git에 의해 버전 관리가 가능한 Git
	저장소로 변환된다. 이후에는 개발자들이 코드를 작성하고 변경 사항을 추적할 수 있다. 개발자는 로컬 저장소
	에서 작업하고, Git을 사용하여 변경 사항을 커밋하고, 로컬 저장소에서 작업을 업데이트할 수 있다.

	GitHub에서 저장소는 Git 저장소에 호스팅되는 것으로 다른 개발자들과 공유할 수 있다.
	개발자들은 Git 저장소를 GitHub에 업로드하고, 다른 개발자들과 협력할 수 있다. 저장소를 공개적으로 공개할 수
	도있고 비공개적으로 개인 또는 팀에서만 사용할 수도 있다.

	저장소는 개발자들이 프로젝트를 추적하고, 버전을 관리하며, 다른 개발자들과 공유하는 데 중요한 역할을 한다.
	Git 및 GutHub에서 저장소는 프로젝트의 핵심이 되는 요소이다.
	로컬 저장소
		여러분의 컴퓨터의 폴더, 여기에 존재하는 파일들만 Git에서 버전 관리를 해준다.
		Working Directory: 현재 작업 공간
		Stage ( or Index ): 수정된 내용들을 추려서 모아두는 임시 곤간
	원격 저장소
		GitHub에서 여러분들을 위한 개별 서버를 준비해 준다. 여러분의 로컬 저장소에 대응되는 온라인 공간인
		셈이다. 로컬 저장소에서 작업을 수행한 다음 commit이라는 과정으로 서버에 변경 사항을 반영하는 구조이다.
커밋(Commit)
	저장소의 변경 내용을 저장하는 것을 의미한다. 개발자들은 파일을 수정하거나 새 파일을 추가한 후, 변경
	사항을 커밋하여 Git 저장소에 저장한다.

	커밋은 Git 저장소의 버전은 생성하며, 각각의 커밋은 고유한 해시값을 가지고 있다. 이를 통해 개발자들은 저장
	소에서 이전 버전으로 쉽게 돌아갈 수 있다.
	커밋은 변경 사항의 설명을 포함하는 커밋 메시지와 함께 생성된다.

	Git에서 커밋은 로컬 저장소에서 생성되며, 다른 개발자들과 공유하기 전에는 로컬 저장소에만
	존재한다. 이후에는 Git을 사용하여 원격 저장소에 커밋을 푸시할 수 있다.
	GitHub에서 커밋은 Git 저장소에 있는 커밋의 역사를 시각적으로 표시하는 그래프로 볼 수 있다.

	커밋은 프로젝트 개발 및 버전 관리에서 중요한 역할을 한다. 커밋을 통해 개발자들은 변경 사항을
	추적하고, 다른 개발자들과 협력할 수 있다. 또한 커밋은 프로젝트를 안정적으로 관리하는데
	필요한 기반을 제공한다.
스태시(Stash)
	현재 작업 중인 변경 사항을 일시적으로 저장하는 기능이다. 개발자들은 작업 중인 변경 사항이나 커밋하지
	않은 파일이 있을 때, 스태시를 사용하여 변경 사항을 일시적으로 저장하고 다른 브렌치로 전환할 수 있다.

	스태시를 사용하면 변경 사항을 커밋하지 않고 일시적으로 저장할 수 있다.
	스태시는 현재 작업 중인 변경 사항을 일시적으로 저장하는 스태시 스택으로 관리된다.
	스태시를 사용하면 변경 사항을 일시적으로 저장하고 다른 브랜치로 저놔,
	작업이 완료된 후 스태시를 다시 적용하여 변경 사항을 복원할 수 있다.

	스태시는 일시적인 변경 사항을 저장할 때 유용하다. 개발자가 여러 작업을 수행하고,
	커밋하지 않은 변경 사항이 있을 때 스태시를 사용하여 변경 사항을 일시적으로 저장하 수잇다.
	이를 통해 다른 브랜치로 전환하여 작업하고, 작업이 완료된 후 스태시를 다시 적용하여 변경 사항을
	복원할 수 있다.
체크인(Check In)
	커밋과 유사한 개념, 체크인은 변경된 코드를 로컬 저장소에 저장하는 것을 의미한다. 체크인은 Git 저장
	소에서 코드의 번전을 생성하며, 버전을 기록한다.

	체크인은 대개 소프르퉤어 개발 프로세스의 일부로 사용된다. 코드를 작성한 후 변경 사항을 로컬
	저장소에 체크인하여 다른 개발자들과 변경 사항을 공유하고 프로젝트를 관리한다.

	Git에서 체크인은 커밋과 , 체크인 메시지를 작성하여 변경 사항을 설명하고, 변경 사항을 로컬 저장소에
	커밋하나. 이후에느 Git을 사용하여 원격 저장소에 치크인을 푸시할 수 있다.

	GitHub에서 체크인은 Git 저장소의 변경 사항을 시각적으로 표시하는 그래프로 볼 수 있다. 체크인
	그래프를 사용하면 개발자들은 저장소의 이전 버전으로 쉽게 돌아갈 수 있다.

	체크인은 Git 및 GitHub에서 프로젝트 개발 및 버전 관리에ㅓ 중요한 역할을 한다.
	체크인을 통해 변경 사항을 추적하고, 다른 개발자들과 협력할 수 있으며 프로젝트를 안정적으로 관리하는데
	필요한 기반을 제공한다.
푸시(Push)
	로컬 저장소에 있는 병셩 사항을 원젹 저장소에 업로드하는 것을 의미한다.
	즉, 로컬 저장소에 작성한 커밋을 원격 저장소에 반영하는 작업이다.
풀(Pull)
	원격 저장소에서 변경된 내욜을 로컬 저장소로 가져오는 작업을 의미한다. 즉, 로컬 저장소와 원격 저장소 간의
	차이점을 확인하고 원격 저장소에서 변경된 코드를 로컬 저장소에 반영하는 작업이다.
브랜치(Branch)
	Git 저장소에서 여러 개발자가 동시에 작업할 수 있는 코드베이스의 복사본입니다.
	브랜치를 사용하면 프로젝트의 다른 버전을 동시에 개발하고, 변경 사항을 다른 브랜치에 적용하고, 변경 사항이 안정화될 때까지
	메인 브랜치에 병합할 수 있다.

	브랜치를 만들면 Git 저장소에서 복사본이 생성된다. 이 복사본은 새로운 브랜치 이름으로 저장된다. 브랜치는 기존의
	커밋을 기반으로 작성된다. 이렇게 하면 개발자들은 독립적으로 다른 브랜치에서 작업할 수 있으며 변경 사항을
	다른 브랜치에 영향을 주지 않고 변경하 ㅅ ㅜ있다.
	각 팀원은 자신이 담당하는 작업에 해당하는 브랙치를 만들고, 작업을 완료한 후 변경 사항을 메인 브랜치로
	병합할 수 있다.
병합(Merge)
	브랜치에서 개발한 변경 사항을 다른 브랜치에 동합하는 것, 이를 통해 여러 개발자가 각각의 브랜치에서
	작업한 변경 사항을 하나의 코드베이스로 병합하여 관리할 수 있다.

	Git에서 병합은 두 개의 브랜치를 선택하고, 변경 사항을 하나로 합치는 과정을 말한다. 일반적으로 병합은
	메인 브랜치로 다른 브랜치에서 변경된 내용을 가져오는 작업이다. 개발자 A와 B가 각각 다른 브랜치에서 작하고
	있다면, 메인 브랜치로 A와 B가 작업한 내뇽을 병합할 수이싸.
http://git-scm.com/book/ko/v2
*/