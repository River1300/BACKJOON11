#pragma once

/*
오류
오류의 종류

컴파일 시간 오류(CompileTimeError)
컴파일러가 찾아 낸 오류로 가장 수정하기 쉬운 오류다.
	문법 오류, 타입 오류
링크 시간 오류(LinkTimeError)
링커가 탐지한 오류로 역시 수정하기 쉽다. 주로 외부 라이브러리의 잘못된 사용으로 발생한다.
실행 시간 오류(RunTimeError)
프로그램을 실행하는 동안 발생하는 오류로 프로그래머가 용의주도하고 꼼꼼하다면 그나마 수정하기 귑다.
	컴퓨터가 감지한 오류 : 컴퓨터가 허용하지 않는 계산을 하려고 할 때 발생
	라이브러리가 감지한 오류 : 라이브러리가 혀용하지 않는 계산에서 발생
	사용자가 감지한 오류 : 프로그래머가 직접 허용되지 않는 계산을 지정하고, 오류를 발생
논리 오류
찾기 가장 어려운 오류/ 입력 -> 연산 -> 결과 모두 문제 없이 실행되는데, 결과가 다름

오류의 원인

잘못된 명세
	프로그램 명세를 프로그램의 목적과 해야할 일을 명시하는 것
	기획서에서 바로 시작하는 경우도 많다. 이러한 명세서에 논리적인 결함이 있을 경우 그대로 구현한 프로그램은 당연히
	오류를 가지고 있다.
불완전한 프로그램
	처음부터 불완전하게 프로그램을 개발하는 프로그래머는 없다. 다만 개발 과정은 시간과의 싸움인지라 부족한
	시간에 쫓기다 보면 어쩔 수 없이 급하게 코딩하는 경우가 생기고 오류가 발생할 수 있다.
예상 밖의 인자
	함수에 사용되는 입력은 주의해야 한다. 나이를 입력 받아 계산하는 함수가 -1과 같이 음수가 매개 변수로 전달되면 어ㄸㄹ가
	문자열을 인자로 받는 함수가 빈 문자열을 받으면
예상 밖의 입력
	프로그램은 주로GUI를 이용해 사용자와 상호 작용한다.
	정수를 입력 받는데 사용자가 문자열을 입력한다거나, 다른 작업을 진행 중에 버튼을 누른다거나 하는 상황이 언제
	든지 발생할 수 있다. 사용자는 절대로 프로그래머나 기획자가 의도한대로 행동하지 안는다.
예상 밖의 상태
	주어진 입력을 계산하기 위해 배열을 사용하고 있다고 가정해 보자, 그런데 이 배열의 내용이 잘못되었다면? 당연히 결과도
	잘못 나올 것이다. 이렇게 계산을 위해 숨겨진 자료 구조는 프로그램을 작성할 때 눈으로 볼 수 ㅇ벗기 때문에 익숙해 지기
	전까지 실수할 가능일서 높다.
논리 오류
	
컴파일 시간 오류
최근 컴파일러는 거의 실시간으로 컴파일 에러를 잡아 주기 때문에 문법 실수, 오타등은 손쉽게 파악할 수 있다.
다만, 에러 메세지는 그리 친절하지 않다.
	오류 : 오류가 발생하면 컴파일이 더이상 진행되지 안흔다.
	경고 : 경고는 컴파일이 성공적으로 진행되고, 프로그램도 실행할 수있다.
	하지만 의도치 않은 결과가 나올 수 있다.

링크 시간 오류
	링크 과정에 발생하는 오류로 조금 어렵긴 하지만 코드를 훑어보면 찾을 수 있다.

예외
	지금까지 살펴본 오류에 대한 처리를 지원하는 것이 예외이며, 예외는 다음과 같이 구성되어 있다.
		오류 발생
			함수가 처리할 수 없는 오류가 발생하면 이를 프로그래머가 인지해서 일반적인 return이 아닌
			예외를 던진다.
		예외 탐지 및 처리
			함수를 직간접적으로 호출한 모든 쪽에서 계산을 시도해보고 예외를 잡아내서 해당 예외에
			대한 처리를 수행

double linear_equation(int a, int b)
	if(a == 0)
		throw std::logic_error("divide by zero!");
	return -((double)b / a);
int main()
	int a;
	int b;
	std::cout<<"두 정수를 입력하세요 : ";
	std::cin>> a >> b;

	try
		std::cout<<linear_equation(a, b);
	catch(std::logic_error)
		std::cerr<< "Divede by zero!";
프로그래머가 계산에서 오류를 탐지하고 logic_error 예외를 던진다.
함수를 사용하기 전에 try{} 구문으로 계산을 시도한다.
try블록에서 던져진 예외를 catch 한다.
예외 대응
예외를 사용하면 지금까지의 오류 처리해 비해 안전하게 처리할 수 있으며, 오류 감지와 처리가 명확하게
분리될 수 있다. 예외에 대한 C++ 사용법은 매우 복잡하고 다양하다.

기본 예외 처리

int main()
	try
		// your code
		return 0;
	catch(std::exception e)
		std::cerr<< "error : "<< e.what();
		return 1;
	catch(...)
		std::cerr<<"unknown error!";
		return 2;
*/